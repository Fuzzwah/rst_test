<h1 class="title">DirectX Intermediate Language</h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#versioning" id="toc-entry-2">Versioning</a><ul>
<li><a class="reference internal" href="#shader-model-sm" id="toc-entry-3">Shader Model (SM)</a></li>
<li><a class="reference internal" href="#dxil-version" id="toc-entry-4">DXIL version</a></li>
<li><a class="reference internal" href="#dxil-1-1-changes" id="toc-entry-5">DXIL 1.1 Changes</a></li>
<li><a class="reference internal" href="#dxil-1-2-changes" id="toc-entry-6">DXIL 1.2 Changes</a></li>
<li><a class="reference internal" href="#llvm-bitcode-version" id="toc-entry-7">LLVM Bitcode version</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-issues" id="toc-entry-8">General Issues</a><ul>
<li><a class="reference internal" href="#terminology" id="toc-entry-9">Terminology</a></li>
<li><a class="reference internal" href="#dxil-abstraction-level" id="toc-entry-10">DXIL abstraction level</a></li>
<li><a class="reference internal" href="#scalar-ir" id="toc-entry-11">Scalar IR</a></li>
<li><a class="reference internal" href="#memory-accesses" id="toc-entry-12">Memory accesses</a></li>
<li><a class="reference internal" href="#out-of-bounds-behavior" id="toc-entry-13">Out-of-bounds behavior</a></li>
<li><a class="reference internal" href="#memory-access-granularity" id="toc-entry-14">Memory access granularity</a></li>
<li><a class="reference internal" href="#number-of-virtual-values" id="toc-entry-15">Number of virtual values</a></li>
<li><a class="reference internal" href="#control-flow-restrictions" id="toc-entry-16">Control-flow restrictions</a></li>
<li><a class="reference internal" href="#functions" id="toc-entry-17">Functions</a></li>
<li><a class="reference internal" href="#identifiers" id="toc-entry-18">Identifiers</a></li>
<li><a class="reference internal" href="#address-width" id="toc-entry-19">Address Width</a></li>
<li><a class="reference internal" href="#shader-restrictions" id="toc-entry-20">Shader restrictions</a></li>
<li><a class="reference internal" href="#entry-points" id="toc-entry-21">Entry points</a></li>
<li><a class="reference internal" href="#hull-shader-representation" id="toc-entry-22">Hull shader representation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-system" id="toc-entry-23">Type System</a><ul>
<li><a class="reference internal" href="#primitive-types" id="toc-entry-24">Primitive Types</a></li>
<li><a class="reference internal" href="#vectors" id="toc-entry-25">Vectors</a></li>
<li><a class="reference internal" href="#matrices" id="toc-entry-26">Matrices</a></li>
<li><a class="reference internal" href="#arrays" id="toc-entry-27">Arrays</a></li>
<li><a class="reference internal" href="#user-defined-types" id="toc-entry-28">User-defined types</a></li>
<li><a class="reference internal" href="#type-conversions" id="toc-entry-29">Type conversions</a></li>
<li><a class="reference internal" href="#precise-qualifier" id="toc-entry-30">Precise qualifier</a></li>
<li><a class="reference internal" href="#type-annotations" id="toc-entry-31">Type annotations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shader-properties-and-capabilities" id="toc-entry-32">Shader Properties and Capabilities</a><ul>
<li><a class="reference internal" href="#shader-flags" id="toc-entry-33">Shader Flags</a></li>
<li><a class="reference internal" href="#geometry-shader" id="toc-entry-34">Geometry Shader</a></li>
<li><a class="reference internal" href="#domain-shader" id="toc-entry-35">Domain Shader</a></li>
<li><a class="reference internal" href="#hull-shader" id="toc-entry-36">Hull Shader</a></li>
<li><a class="reference internal" href="#compute-shader" id="toc-entry-37">Compute Shader</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shader-parameters-and-signatures" id="toc-entry-38">Shader Parameters and Signatures</a><ul>
<li><a class="reference internal" href="#hlsl-signatures-and-semantics" id="toc-entry-39">HLSL signatures and semantics</a></li>
<li><a class="reference internal" href="#signature-element-record" id="toc-entry-40">Signature element record</a></li>
<li><a class="reference internal" href="#signature-record-metadata" id="toc-entry-41">Signature record metadata</a></li>
<li><a class="reference internal" href="#accessing-signature-value-in-operations" id="toc-entry-42">Accessing signature value in operations</a></li>
<li><a class="reference internal" href="#signature-packing" id="toc-entry-43">Signature packing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shader-resources" id="toc-entry-44">Shader Resources</a><ul>
<li><a class="reference internal" href="#metadata-resource-records" id="toc-entry-45">Metadata resource records</a></li>
<li><a class="reference internal" href="#reflection-information" id="toc-entry-46">Reflection information</a></li>
<li><a class="reference internal" href="#structure-of-resource-operation" id="toc-entry-47">Structure of resource operation</a></li>
<li><a class="reference internal" href="#resource-operations" id="toc-entry-48">Resource operations</a></li>
<li><a class="reference internal" href="#samplers" id="toc-entry-49">Samplers</a></li>
<li><a class="reference internal" href="#immediate-constant-buffer" id="toc-entry-50">Immediate Constant Buffer</a></li>
<li><a class="reference internal" href="#texture-buffers" id="toc-entry-51">Texture Buffers</a></li>
<li><a class="reference internal" href="#groupshared-memory" id="toc-entry-52">Groupshared memory</a></li>
<li><a class="reference internal" href="#indexable-threadlocal-memory" id="toc-entry-53">Indexable threadlocal memory</a></li>
<li><a class="reference internal" href="#load-store-atomics-via-pointer-in-future-sm" id="toc-entry-54">Load/Store/Atomics via pointer in future SM</a></li>
<li><a class="reference internal" href="#additional-resource-properties" id="toc-entry-55">Additional resource properties</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operations" id="toc-entry-56">Operations</a><ul>
<li><a class="reference internal" href="#operations-via-instructions" id="toc-entry-57">Operations via instructions</a></li>
<li><a class="reference internal" href="#operations-via-external-functions" id="toc-entry-58">Operations via external functions</a></li>
<li><a class="reference internal" href="#custom-instructions" id="toc-entry-59">Custom instructions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#validation-rules" id="toc-entry-60">Validation Rules</a></li>
<li><a class="reference internal" href="#modules-and-linking" id="toc-entry-61">Modules and Linking</a></li>
<li><a class="reference internal" href="#additional-notes" id="toc-entry-62">Additional Notes</a><ul>
<li><a class="reference internal" href="#other-versioned-components" id="toc-entry-63">Other Versioned Components</a></li>
<li><a class="reference internal" href="#dxil-container-format" id="toc-entry-64">DXIL Container Format</a></li>
<li><a class="reference internal" href="#future-directions" id="toc-entry-65">Future Directions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pending-specification-work" id="toc-entry-66">Pending Specification Work</a></li>
</ul>
</div>
<a name="introduction"></a>
<h2><a class="toc-backref" href="#toc-entry-1">Introduction</a></h2>
<p>This document presents the design of the DirectX Intermediate Language (DXIL) for GPU shaders. DXIL is intended to support a direct mapping of the HLSL programming language into Low-Level Virtual Machine Intermediate Representation (LLVM IR), suitable for consumption in GPU drivers. This version of the specification is based on LLVM 3.7 in the use of metadata syntax.</p>
<p>Prior to being converted into the low-level DXIL IR, a higher level IR is generated by codegen which is then transformed into DXIL by the optimizer. This lowers high-level constructs, such as user-defined types, multi-dimensional arrays, matrices, and vectors into simpler abstractions more suitable for fast JIT-ing in the driver compilers. DXIL is derived from LLVM IR.</p>
<p>LLVM is quickly becoming a de facto standard in modern compilation technology. The LLVM framework offers several distinct features, such as a vibrant ecosystem, complete compilation framework, modular design, and reasonable documentation. We can leverage these to achieve two important objectives.</p>
<p>First, unification of shader compilation tool chain. DXIL is a contract between IR producers, such as compilers for HLSL and other domain-specific languages, and IR consumers, such as IHV driver JIT compilers or offline XBOX shader compiler. In addition, the design provides for conversion of the legacy HLSL IL, called DXBC IL in this document, to DXIL.</p>
<p>Second, leveraging the LLVM ecosystem. Microsoft will publicly document DXIL to attract domain language implementers and spur innovation. Using LLVM-based IR offers reduced entry costs for small teams, simply because small teams are likely to use LLVM and Clang as their main compilation framework. We will provide DXIL validator to check consistency of generated DXIL.</p>
<p>The following diagram shows how some of these components tie together:</p>
<pre>
HLSL   Other shading langs  DSL          DXBC IL
+      +                    +            +
|      |                    |            |
v      v                    v            v
Clang  Clang                Other Tools  dxbc2dxil
+      +                    +            +
|      |                    |            |
v      v                    v            |
+------+--------------------+---------+  |
|          High level IR              |  |
+-------------------------------------+  |
                  |                      |
                  |                      |
                  v                      |
              Optimizer &lt;-----+ Linker   |
              +      ^             +     |
              |      |             |     |
              |      |             |     |
 +------------v------+-------------v-----v-------+
 |              Low level IR (DXIL)              |
 +------------+----------------------+-----------+
              |                      |
              v                      v
      Driver Compiler             Validator
</pre>
<p>The <em>dxbc2dxil</em> element in the diagram is a component that converts existing DXBC shader byte code into DXIL. The <em>Optimizer</em> element is a component that consumes the high level IR, verifies it is valid, optimizes it, and produces a valid DXIL form. The <em>Validator</em> element is a public component that verifies and signs DXIL. The <em>Linker</em> is a component that combines precompiled DXIL libraries with the entry function to produce a valid shader.</p>
<p>DXIL does not support the following HLSL features that were present in prior implementations.</p>
<ul class="simple">
<li>Shader models 9 and below. Microsoft may implement 10level9 shader models via DXIL capability tiers.</li>
<li>Effects.</li>
<li>HLSL interfaces.</li>
<li>Shader compression/decompression.</li>
<li>Partial precision. Half data type should be used instead.</li>
<li>min10float type. Half data type should be used instead.</li>
<li>HLSL <em>uniform</em> parameter qualifier.</li>
<li>Current fxc legacy compatibility mode for old shader models (e.g., c-register binding).</li>
<li>PDB. Debug Information annotations are used instead.</li>
<li>Compute shader model cs_4_0.</li>
<li>DXBC label, call, fcall constructs.</li>
</ul>
<p>The following principles are used to ease reuse with LLVM components and aid extensibility.</p>
<ul class="simple">
<li>DXIL uses a subset of LLVM IR constructs that makes sense for HLSL.</li>
<li>No modifications to the core LLVM IR; i.e., no new instructions or fundamental types.</li>
<li>Additional information is conveyed via metadata, LLVM intrinsics or external functions.</li>
<li>Name prefixes: 'llvm.dx.', 'llvm.dxil.', 'dx.', and 'dxil.' are reserved.</li>
</ul>
<a name="versioning"></a>
<h2><a class="toc-backref" href="#toc-entry-2">Versioning</a></h2>
<p>There are three versioning mechanisms in DXIL shaders: shader model, DXIL version, and LLVM bitcode version.</p>
<p>At a high-level, the shader model describes the target execution model and environment.</p>
<p>DXIL defines the rules for expressing Direct3D shader programs using a subset of standard LLVM IR. LLVM IR has three equivalent forms: human-readable, binary (bitcode), and in-memory. DXIL programs are encoded using a subset of LLVM IR bitcode format. This document uses only human-readable form to describe DXIL.</p>
<p>DXIL versioning allows for changes to the rules over time. The LLVM bitcode version is currently fixed at LLVM 3.7 for all DXIL versions.</p>
<p>A given DXIL version can support up to the latest shader model defined at the time that DXIL version was finalized. However, the DXIL version for a shader is typically set based on the shader model to ensure that any device supporting that particular shader model will be able to interpret the DXIL properly, without needing to know about any newer DXIL versions.</p>
<a name="shader-model-sm"></a>
<h3><a class="toc-backref" href="#toc-entry-3">Shader Model (SM)</a></h3>
<p>The shader model in DXIL is similar to DXBC shader model. A shader model specifies the execution model, the set of capabilities that shader instructions can use and the constraints that a shader program must adhere to.</p>
<p>The shader model is specified as a named metadata in DXIL:</p>
<pre>
!dx.shaderModel = !{ !0 }
!0 = !{ !&quot;&lt;shadelModelName&gt;&quot;, i32 &lt;major&gt;, i32 &lt;minor&gt; }
</pre>
<p>The following values of <code>&lt;shaderModelName&gt;</code>, <code>&lt;major&gt;</code>, <code>&lt;minor&gt;</code> are supported:</p>
<table class="docutils">
<colgroup>
<col width="34%" />
<col width="38%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Shader Tyoe</th>
<th class="head">shaderModelName</th>
<th class="head">Minimum major, minor</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Vertex shader (VS)</td>
<td>vs</td>
<td>6, 0</td>
</tr>
<tr><td>Hull shader (HS)</td>
<td>hs</td>
<td>6, 0</td>
</tr>
<tr><td>Domain shader (DS)</td>
<td>ds</td>
<td>6, 0</td>
</tr>
<tr><td>Geometry shader (GS)</td>
<td>gs</td>
<td>6, 0</td>
</tr>
<tr><td>Pixel shader (PS)</td>
<td>ps</td>
<td>6, 0</td>
</tr>
<tr><td>Compute shader (CS)</td>
<td>cs</td>
<td>6, 0</td>
</tr>
<tr><td>Mesh shader (MS)</td>
<td>ms</td>
<td>6, 5</td>
</tr>
<tr><td>Amplification shader (AS)</td>
<td>as</td>
<td>6, 5</td>
</tr>
<tr><td>DXIL library</td>
<td>lib</td>
<td>6, 3</td>
</tr>
</tbody>
</table>
<p>The DXIL validator ensures that DXIL conforms to the specified shader model.</p>
<a name="dxil-version"></a>
<h3><a class="toc-backref" href="#toc-entry-4">DXIL version</a></h3>
<p>The primary mechanism to evolve HLSL capabilities is through shader models. However, DXIL version is reserved for additional flexibility of future extensions. There are two currently defined versions: 1.0 and 1.1.</p>
<p>DXIL version has major and minor versions that are specified as named metadata:</p>
<pre>
!dx.version = !{ !0 }
!0 = !{ i32 &lt;major&gt;, i32 &lt;minor&gt; }
</pre>
<p>DXIL version must be declared exactly once per LLVM module (translation unit) and is valid for the entire module.</p>
<p>DXIL will evolve in a manner that retains backward compatibility.</p>
<a name="dxil-1-1-changes"></a>
<h3><a class="toc-backref" href="#toc-entry-5">DXIL 1.1 Changes</a></h3>
<p>Main two features that were introduced for DXIL1.1 (Shader Model 6.1) are view instancing and barycentric coordinates. Specifically, there are following changes to the DXIL representation.</p>
<ul class="simple">
<li>New Intrinsics - <a class="reference internal" href="#attributeatvertex">AttributeAtVertex</a>, ViewID</li>
<li>New System Generated Value - SV_Barycentrics</li>
<li>New Container Part - ILDN</li>
</ul>
<a name="dxil-1-2-changes"></a>
<h3><a class="toc-backref" href="#toc-entry-6">DXIL 1.2 Changes</a></h3>
<ul class="simple">
<li>RawBufferLoad and RawBufferStore DXIL operations for ByteAddressBuffer and StructuredBuffer</li>
<li>Denorm mode as a function attribute for float32 &quot;fp32-denorm-mode&quot;=&lt;value&gt;</li>
</ul>
<a name="llvm-bitcode-version"></a>
<h3><a class="toc-backref" href="#toc-entry-7">LLVM Bitcode version</a></h3>
<p>The current version of DXIL is based on LLVM bitcode v3.7. This encoding is necessarily implied by something outside the DXIL module.</p>
<a name="general-issues"></a>
<h2><a class="toc-backref" href="#toc-entry-8">General Issues</a></h2>
<p>An important goal is to enable HLSL to be closer to a strict subset of C/C++. This has implications for DXIL design and future hardware feature requests outlined below.</p>
<a name="terminology"></a>
<h3><a class="toc-backref" href="#toc-entry-9">Terminology</a></h3>
<p>Resource refers to one of the following:</p>
<ul class="simple">
<li>SRV - shader resource view (read-only)</li>
<li>UAV - unordered access view (read-write)</li>
<li>CBV - constant buffer view (read-only)</li>
<li>Sampler</li>
</ul>
<p>Intrinsics typically refer to operations missing in the core LLVM IR. DXIL represents HLSL built-in functions (also called intrinsics) not as LLVM intrinsics, but rather as external function calls.</p>
<a name="dxil-abstraction-level"></a>
<h3><a class="toc-backref" href="#toc-entry-10">DXIL abstraction level</a></h3>
<p>DXIL has level of abstraction similar to a 'scalarized' DXBC. DXIL is a lower level IR amenable to fast and robust JIT-ing in driver compilers.</p>
<p>In particular, the following passes are performed to lower the HLSL abstractions down to DXIL:</p>
<ul class="simple">
<li>optimize function parameter copies</li>
<li>inline functions</li>
<li>allocate and transform shader signatures</li>
<li>lower matrices, optimizing intermediate storage</li>
<li>linearize multi-dimensional arrays and user-defined type accesses</li>
<li>scalarize vectors</li>
</ul>
<a name="scalar-ir"></a>
<h3><a class="toc-backref" href="#toc-entry-11">Scalar IR</a></h3>
<p>DXIL operations work with scalar quantities. Several scalar quantities may be grouped together in a struct to represent several return values, which is used for memory operations, e.g., load/store, sample, etc., that benefit from access coalescing.</p>
<p>Metadata, resource declarations, and debugging info may contain vectors to more closely convey source code shape to tools and debuggers.</p>
<p>Future versions of IR may contain vectors or grouping hints for less-than-32-bit quantities, such as half and i16.</p>
<a name="memory-accesses"></a>
<h3><a class="toc-backref" href="#toc-entry-12">Memory accesses</a></h3>
<p>DXIL conceptually aligns with DXBC in how different memory types are accessed. Out-of-bounds behavior and various restrictions are preserved.</p>
<p>Indexable thread-local and groupshared variables are represented as variables and accessed via LLVM C-like pointers.</p>
<p>Swizzled resources, such as textures, have opaque memory layouts from a DXIL point of view. Accesses to these resources are done via intrinsics.</p>
<p>There are two layouts for constant buffer memory: (1) legacy, matching DXBC's layout and (2) linear layout. SM6 DXIL uses intrinsics to read cbuffer for either layout.</p>
<p>Shader signatures require packing and are located in a special type of memory that cannot be viewed as linear. Accesses to signature values are done via special intrinsics in DXIL. If a signature parameter needs to be passed to a function, a copy is created first in threadlocal memory and the copy is passed to the function.</p>
<p>Typed buffers represent memory with in-flight data conversion. Typed buffer load/store/atomics are done via special functions in DXIL with element-granularity indexing.</p>
<p>The following pointer types are supported:</p>
<ul class="simple">
<li>Non-indexable thread-local variables.</li>
<li>Indexable thread-local variables (DXBC x-registers).</li>
<li>Groupshared variables (DXBC g-registers).</li>
<li>Device memory pointer.</li>
<li>Constant-buffer-like memory pointer.</li>
</ul>
<p>The type of DXIL pointer is differentiated by LLVM addrspace construct. The HLSL compiler will make the best effort to infer the exact pointer addrspace such that a driver compiler can issue the most efficient instruction.</p>
<p>A pointer can come into being in a number of ways:</p>
<ul class="simple">
<li>Global Variables.</li>
<li>AllocaInst.</li>
<li>Synthesized as a result of some pointer arithmetic.</li>
</ul>
<p>DXIL uses 32-bit pointers in its representation.</p>
<a name="out-of-bounds-behavior"></a>
<h3><a class="toc-backref" href="#toc-entry-13">Out-of-bounds behavior</a></h3>
<p>Indexable thread-local accesses are done via LLVM pointer and have C-like OOB semantics.
Groupshared accesses are done via LLVM pointer too. The origin of a groupshared pointer must be a single TGSM allocation.
If a groupshared pointer uses in-bound GEP instruction, it should not OOB. The behavior for an OOB access for in-bound pointer is undefined.
For groupshared pointer from regular GEP, OOB will has same behavior as DXBC. Loads return 0 for OOB accesses; OOB stores are silently dropped.</p>
<p>Resource accesses keeps the same out-of-bounds behavior as DXBC. Loads return 0 for OOB accesses; OOB stores are silently dropped.</p>
<p>OOB pointer accesses in SM6.0 and later have undefined (C-like) behavior. LLVM memory optimization passes can be used to optimize such accesses. Where out-of-bound behavior is desired, intrinsic functions are used to access memory.</p>
<a name="memory-access-granularity"></a>
<h3><a class="toc-backref" href="#toc-entry-14">Memory access granularity</a></h3>
<p>Intrinsic and resource accesses may imply a wider access than requested by an instruction. DXIL defines memory accesses for i1, i16, i32, i64, f16, f32, f64 on thread local memory, and i32, f32, f64 for memory I/O (that is, groupshared memory and memory accessed via resources such as CBs, UAVs and SRVs).</p>
<a name="number-of-virtual-values"></a>
<h3><a class="toc-backref" href="#toc-entry-15">Number of virtual values</a></h3>
<p>There is no limit on the number of virtual values in DXIL. The IR is guaranteed to be in an SSA form. For optimized shaders, the optimizer will run -mem2reg LLVM pass as well as perform other memory to register promotions if profitable.</p>
<a name="control-flow-restrictions"></a>
<h3><a class="toc-backref" href="#toc-entry-16">Control-flow restrictions</a></h3>
<p>The DXIL control-flow graph must be reducible, as checked by T1-T2 test. DXIL does not preserve structured control flow of DXBC. Preserving structured control-flow property would impose significant burden on third-party tools optimizing to DXIL via LLVM, reducing appeal of DXIL.</p>
<p>DXIL allows fall-through for switch label blocks. This is a difference from DXBC, in which the fall-through is prohibited.</p>
<p>DXIL will not support the DXBC label and call instructions; LLVM functions can be used instead (see below). The primary uses for these are (1) HLSL interfaces, which are not supported, and (2) outlining of case-bodies in a switch statement annotated with [call], which is not a scenario of interest.</p>
<a name="functions"></a>
<h3><a class="toc-backref" href="#toc-entry-17">Functions</a></h3>
<p>Instead of DXBC labels/calls, DXIL supports functions and call instructions. Recursion is not allowed; DXIL validator enforces this.</p>
<p>The functions are regular LLVM functions. Parameters can be passed by-value or by-reference. The functions are to facilitate separate compilation for big, complex shaders. However, driver compilers are free to inline functions as they see fit.</p>
<a name="identifiers"></a>
<h3><a class="toc-backref" href="#toc-entry-18">Identifiers</a></h3>
<p>DXIL identifiers must conform to LLVM IR identifier rules.</p>
<p>Identifier mangling rules are the ones used by Clang 3.7 with the HLSL target.</p>
<p>The following identifier prefixes are reserved:</p>
<ul class="simple">
<li>dx.*, dxil.*</li>
<li>llvm.dx.*, llvm.dxil.*</li>
</ul>
<a name="address-width"></a>
<h3><a class="toc-backref" href="#toc-entry-19">Address Width</a></h3>
<p>DXIL will use only 32-bit addresses for pointers. Byte offsets are also 32-bit.</p>
<a name="shader-restrictions"></a>
<h3><a class="toc-backref" href="#toc-entry-20">Shader restrictions</a></h3>
<p>There is no support for the following in DXIL:</p>
<ul class="simple">
<li>recursion</li>
<li>exceptions</li>
<li>indirect function calls and dynamic dispatch</li>
</ul>
<a name="entry-points"></a>
<h3><a class="toc-backref" href="#toc-entry-21">Entry points</a></h3>
<p>The dx.entryPoints metadata specifies a list of entry point records, one for each entry point. Libraries could specify more than one entry point per module but currently exist outside the DXIL specification; the other shader models must specify exactly one entry point.</p>
<p>For example:</p>
<pre>
define void &#64;&quot;\01?myfunc1&#64;&#64;YAXXZ&quot;() #0 { ... }
define float &#64;&quot;\01?myfunc2&#64;&#64;YAMXZ&quot;() #0 { ... }

!dx.entryPoints = !{ !1, !2 }

!1 = !{ void  ()* &#64;&quot;\01?myfunc1&#64;&#64;YAXXZ&quot;, !&quot;myfunc1&quot;, !3, null, null }
!2 = !{ float ()* &#64;&quot;\01?myfunc2&#64;&#64;YAMXZ&quot;, !&quot;myfunc2&quot;, !5, !6, !7 }
</pre>
<p>Each entry point metadata record specifies:</p>
<ul class="simple">
<li>reference to the entry point function global symbol</li>
<li>unmangled name</li>
<li>list of signatures</li>
<li>list of resources</li>
<li>list of tag-value pairs of shader capabilities and other properties</li>
</ul>
<p>A 'null' value specifies absence of a particular node.</p>
<p>Shader capabilities are properties that are additional to properties dictated by shader model. The list is organized as pairs of i32 tag, followed immediately by the value itself.</p>
<a name="hull-shader-representation"></a>
<h3><a class="toc-backref" href="#toc-entry-22">Hull shader representation</a></h3>
<p>The hull shader is represented as two functions, related via metadata: (1) control point phase function, which is the entry point of the hull shader, and (2) patch constant phase function.</p>
<p>For example:</p>
<pre>
!dx.entryPoints = !{ !1 }
!1 = !{ void ()* &#64;&quot;ControlPointFunc&quot;, ..., !2 }  ; shader entry record
!2 = !{ !&quot;HS&quot;, !3 }
!3 = !{ void ()* &#64;&quot;PatchConstFunc&quot;, ... }        ; additional hull shader state
</pre>
<p>The patch constant function represents original HLSL computation, and is not separated into fork and join phases, as it is the case in DXBC. The driver compiler may perform such separation if this is profitable for the target GPU.</p>
<p>In DXBC to DXIL conversion, the original patch constant function cannot be recovered during DXBC-to-DXIL conversion. Instead, instructions of each fork and join phases are 'wrapped' by a loop that iterates the corresponding number of phase-instance-count iterations. Thus, fork/join instance ID becomes the loop induction variable. LoadPatchConstant intrinsic (see below) represents load from DXBC vpc register.</p>
<p>The following table summarizes the names of intrinsic functions to load inputs and store outputs of hull and domain shaders. CP stands for Control Point, PC - for Patch Constant.</p>
<table class="docutils">
<colgroup>
<col width="23%" />
<col width="24%" />
<col width="27%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operation</th>
<th class="head">Control Point (Hull)</th>
<th class="head">Patch Constant</th>
<th class="head">Domain</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Store Input CP</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>Load Input CP</td>
<td>LoadInput</td>
<td>LoadInput</td>
<td>&nbsp;</td>
</tr>
<tr><td>Store Output CP</td>
<td>StoreOutput</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>Load Output CP</td>
<td>&nbsp;</td>
<td>LoadOutputControlPoint</td>
<td>LoadInput</td>
</tr>
<tr><td>Store PC</td>
<td>&nbsp;</td>
<td>StorePatchConstant</td>
<td>&nbsp;</td>
</tr>
<tr><td>Load PC</td>
<td>&nbsp;</td>
<td>LoadPatchConstant</td>
<td>LoadPatchConstant</td>
</tr>
<tr><td>Store Output Vertex</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>StoreOutput</td>
</tr>
</tbody>
</table>
<p>LoadPatchConstant function in PC stage is generated only by DXBC-to-DXIL converter, to access DXBC vpc registers. HLSL compiler produces IR that references LLVM IR values directly.</p>
<a name="type-system"></a>
<h2><a class="toc-backref" href="#toc-entry-23">Type System</a></h2>
<p>Most of LLVM type system constructs are legal in DXIL.</p>
<a name="primitive-types"></a>
<h3><a class="toc-backref" href="#toc-entry-24">Primitive Types</a></h3>
<p>The following types are supported:</p>
<ul class="simple">
<li>void</li>
<li>metadata</li>
<li>i1, i8, i16, i32, i64</li>
<li>half, float, double</li>
</ul>
<p>SM6.0 assumes native hardware support for i32 and float types.</p>
<p>i8 is supported only in a few intrinsics to signify masks, enumeration constant values, or in metadata. It's not supported for memory access or computation by the shader.</p>
<p>HLSL min12int, min16int and min16uint data types are mapped to i16.</p>
<p>half and i16 are treated as corresponding DXBC min-presicion types (min16float, min16int/min16uint) in SM6.0.</p>
<p>The HLSL compiler optimizer treats half, i16 and i8 data as data types natively supported by the hardware; i.e., saturation, range clipping, INF/NaN are done according to the IEEE standard. Such semantics allow the optimizer to reuse LLVM optimization passes.</p>
<p>Hardware support for doubles in optional and is guarded by RequiresHardwareDouble CAP bit.</p>
<p>Hardware support for i64 is optional and is guarded by a CAP bit.</p>
<a name="vectors"></a>
<h3><a class="toc-backref" href="#toc-entry-25">Vectors</a></h3>
<p>HLSL vectors are scalarized. They do not participate in computation; however, they may be present in declarations to convey original variable layout to tools, debuggers, and reflection.</p>
<p>Future DXIL may add support for &lt;2 x half&gt; and &lt;2 x i16&gt; vectors or hints for packing related half and i16 quantities.</p>
<a name="matrices"></a>
<h3><a class="toc-backref" href="#toc-entry-26">Matrices</a></h3>
<p>Matrices are lowered to vectors, and are not referenced by instructions. They may be present in declarations to convey original variable layout to tools, debuggers, and reflection.</p>
<a name="arrays"></a>
<h3><a class="toc-backref" href="#toc-entry-27">Arrays</a></h3>
<p>Instructions may reference only 1D arrays of primitive types. However, complex arrays, e.g., multidimensional arrays or user-defined types, may be present to convey original variable layout to tools, debuggers, and reflection.</p>
<a name="user-defined-types"></a>
<h3><a class="toc-backref" href="#toc-entry-28">User-defined types</a></h3>
<p>Original HLSL UDTs are lowered and are not referenced by instructions. However, they may be present in declarations to convey original variable layout to tools, debuggers, and reflection. Some resource operations return 'grouping' UDTs that group several return values; such UDTs are immediately 'decomposed' into components that are then consumed by other instructions.</p>
<a name="type-conversions"></a>
<h3><a class="toc-backref" href="#toc-entry-29">Type conversions</a></h3>
<p>Explicit conversions between types are supported via LLVM instructions.</p>
<a name="precise-qualifier"></a>
<h3><a class="toc-backref" href="#toc-entry-30">Precise qualifier</a></h3>
<p>By default, all floating-point HLSL operations are considered 'fast' or non-precise. HLSL and driver compilers are allowed to refactor such operations. Non-precise LLVM instructions: fadd, fsub, fmul, fdiv, frem, fcmp are marked with 'fast' math flags.</p>
<p>HLSL precise type qualifier requires that all operations contributing to the value be IEEE compliant with respect to optimizations. The /Gis compiler switch implicitly declares all variables and values as precise.</p>
<p>Precise behavior is represented in LLVM instructions: fadd, fsub, fmul, fdiv, frem, fcmp by not having 'fast' math flags set. Each relevant call instruction that contributes to computation of a precise value is annotated with dx.precise metadata that indicates that it is illegal for the driver compiler to perform IEEE-unsafe optimizations.</p>
<a name="type-annotations"></a>
<h3><a class="toc-backref" href="#toc-entry-31">Type annotations</a></h3>
<p>User-defined types are annotated in DXIL to 'attach' additional properties to structure fields. For example, DXIL may contain type annotations of structures and funcitons for reflection purposes:</p>
<pre>
namespace MyNameSpace {
  struct MyType {
      float field1;
      int2 field2;
  };
}

float main(float col : COLOR) : SV_Target {
  .....
}

!dx.typeAnnotations = !{!3, !7}
!3 = !{i32 0, %&quot;struct.MyNameSpace::MyType&quot; undef, !4}
!4 = !{i32 12, !5, !6}
!5 = !{i32 6, !&quot;field1&quot;, i32 3, i32 0, i32 7, i32 9}
!6 = !{i32 6, !&quot;field2&quot;, i32 3, i32 4, i32 7, i32 4}
!7 = !{i32 1, void (float, float*)* &#64;&quot;main&quot;, !8}
!8 = !{!9, !11, !14}
!9 = !{i32 0, !10, !10}
!10 = !{}
!11 = !{i32 0, !12, !13}
!12 = !{i32 4, !&quot;COLOR&quot;, i32 7, i32 9}
!13 = !{i32 0}
!14 = !{i32 1, !15, !13}
!15 = !{i32 4, !&quot;SV_Target&quot;, i32 7, i32 9}
!16 = !{null, !&quot;lib.no::entry&quot;, null, null, null}
</pre>
<p>The type/field annotation metadata hierarchy recursively mimics LLVM type hierarchy.
dx.typeAnnotations is a metadata of type annotation nodes, where each node represents type annotation of a certain type:</p>
<pre>
!dx.typeAnnotations = !{!3, !7}
</pre>
<p>For each <strong>type annotation</strong> node, the first value represents the type of the annotation:</p>
<pre>
!3 = !{i32 0, %&quot;struct.MyNameSpace::MyType&quot; undef, !4}
!7 = !{i32 1, void (float, float*)* &#64;&quot;main&quot;, !8}
</pre>
<table class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>Structure Annotation</td>
</tr>
<tr><td>1</td>
<td>Function Annotation</td>
</tr>
</tbody>
</table>
<p>The second value represents the name, the third is a corresponding type metadata node.</p>
<p><strong>Structure Annotation</strong> starts with the size of the structure in bytes, followed by the list of field annotations:</p>
<pre>
!4 = !{i32 12, !5, !6}
!5 = !{i32 6, !&quot;field1&quot;, i32 3, i32 0, i32 7, i32 9}
!6 = !{i32 6, !&quot;field2&quot;, i32 3, i32 4, i32 7, i32 4}
</pre>
<p><strong>Field Annotation</strong> is a series of pairs with tag number followed by its value. Field Annotation pair is defined as follows</p>
<table class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>SNorm</td>
</tr>
<tr><td>1</td>
<td>UNorm</td>
</tr>
<tr><td>2</td>
<td>Matrix</td>
</tr>
<tr><td>3</td>
<td>Buffer Offset</td>
</tr>
<tr><td>4</td>
<td>Semantic String</td>
</tr>
<tr><td>5</td>
<td>Interpolation Mode</td>
</tr>
<tr><td>6</td>
<td>Field Name</td>
</tr>
<tr><td>7</td>
<td>Component Type</td>
</tr>
<tr><td>8</td>
<td>Precise</td>
</tr>
</tbody>
</table>
<p><strong>Function Annotation</strong> is a series of parameter annotations:</p>
<pre>
!7 = !{i32 1, void (float, float*)* &#64;&quot;main&quot;, !8}
!8 = !{!9, !11, !14}
</pre>
<p>Each <strong>Parameter Annotation</strong> contains Input/Output type, field annotation, and semantic index:</p>
<pre>
!9 = !{i32 0, !10, !10}
!10 = !{}
!11 = !{i32 0, !12, !13}
!12 = !{i32 4, !&quot;COLOR&quot;, i32 7, i32 9}
!13 = !{i32 0}
!14 = !{i32 1, !15, !13}
!15 = !{i32 4, !&quot;SV_Target&quot;, i32 7, i32 9}
</pre>
<a name="shader-properties-and-capabilities"></a>
<h2><a class="toc-backref" href="#toc-entry-32">Shader Properties and Capabilities</a></h2>
<p>Additional shader properties are specified via tag-value pair list, which is the last element in the entry function description record.</p>
<a name="shader-flags"></a>
<h3><a class="toc-backref" href="#toc-entry-33">Shader Flags</a></h3>
<p>Shaders have additional flags that covey their capabilities via tag-value pair with tag kDxilShaderFlagsTag (0), followed by an i64 bitmask integer. The bits have the following meaning:</p>
<table class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Bit</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>Disable shader optimizations</td>
</tr>
<tr><td>1</td>
<td>Disable math refactoring</td>
</tr>
<tr><td>2</td>
<td>Shader uses doubles</td>
</tr>
<tr><td>3</td>
<td>Force early depth stencil</td>
</tr>
<tr><td>4</td>
<td>Enable raw and structured buffers</td>
</tr>
<tr><td>5</td>
<td>Shader uses min-precision, expressed as half and i16</td>
</tr>
<tr><td>6</td>
<td>Shader uses double extension intrinsics</td>
</tr>
<tr><td>7</td>
<td>Shader uses MSAD</td>
</tr>
<tr><td>8</td>
<td>All resources must be bound for the duration of shader execution</td>
</tr>
<tr><td>9</td>
<td>Enable view port and RT array index from any stage feeding rasterizer</td>
</tr>
<tr><td>10</td>
<td>Shader uses inner coverage</td>
</tr>
<tr><td>11</td>
<td>Shader uses stencil</td>
</tr>
<tr><td>12</td>
<td>Shader uses intrinsics that access tiled resources</td>
</tr>
<tr><td>13</td>
<td>Shader uses relaxed typed UAV load formats</td>
</tr>
<tr><td>14</td>
<td>Shader uses Level9 comparison filtering</td>
</tr>
<tr><td>15</td>
<td>Shader uses up to 64 UAVs</td>
</tr>
<tr><td>16</td>
<td>Shader uses UAVs</td>
</tr>
<tr><td>17</td>
<td>Shader uses CS4 raw and structured buffers</td>
</tr>
<tr><td>18</td>
<td>Shader uses Rasterizer Ordered Views</td>
</tr>
<tr><td>19</td>
<td>Shader uses wave intrinsics</td>
</tr>
<tr><td>20</td>
<td>Shader uses int64 instructions</td>
</tr>
</tbody>
</table>
<a name="geometry-shader"></a>
<h3><a class="toc-backref" href="#toc-entry-34">Geometry Shader</a></h3>
<p>Geometry shader properties are specified via tag-value pair with tag kDxilGSStateTag (1), followed by a list of GS properties. The format of this list is the following.</p>
<table class="docutils">
<colgroup>
<col width="4%" />
<col width="6%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>i32</td>
<td>Input primitive (InputPrimitive enum value).</td>
</tr>
<tr><td>1</td>
<td>i32</td>
<td>Max vertex count.</td>
</tr>
<tr><td>2</td>
<td>i32</td>
<td>Primitive topology for stream 0 (PrimitiveTopology enum value).</td>
</tr>
<tr><td>3</td>
<td>i32</td>
<td>Primitive topology for stream 1 (PrimitiveTopology enum value).</td>
</tr>
<tr><td>4</td>
<td>i32</td>
<td>Primitive topology for stream 2 (PrimitiveTopology enum value).</td>
</tr>
<tr><td>5</td>
<td>i32</td>
<td>Primitive topology for stream 3 (PrimitiveTopology enum value).</td>
</tr>
</tbody>
</table>
<a name="domain-shader"></a>
<h3><a class="toc-backref" href="#toc-entry-35">Domain Shader</a></h3>
<p>Domain shader properties are specified via tag-value pair with tag kDxilDSStateTag (2), followed by a list of DS properties. The format of this list is the following.</p>
<table class="docutils">
<colgroup>
<col width="4%" />
<col width="6%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>i32</td>
<td>Tessellator domain (TessellatorDomain enum value).</td>
</tr>
<tr><td>1</td>
<td>i32</td>
<td>Input control point count.</td>
</tr>
</tbody>
</table>
<a name="hull-shader"></a>
<h3><a class="toc-backref" href="#toc-entry-36">Hull Shader</a></h3>
<p>Hull shader properties are specified via tag-value pair with tag kDxilHSStateTag (3), followed by a list of HS properties. The format of this list is the following.</p>
<table class="docutils">
<colgroup>
<col width="4%" />
<col width="9%" />
<col width="87%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>MDValue</td>
<td>Patch constant function (global symbol).</td>
</tr>
<tr><td>1</td>
<td>i32</td>
<td>Input control point count.</td>
</tr>
<tr><td>2</td>
<td>i32</td>
<td>Output control point count.</td>
</tr>
<tr><td>3</td>
<td>i32</td>
<td>Tessellator domain (TessellatorDomain enum value).</td>
</tr>
<tr><td>4</td>
<td>i32</td>
<td>Tessellator partitioning (TessellatorPartitioning enum value).</td>
</tr>
<tr><td>5</td>
<td>i32</td>
<td>Tessellator output primitive (TessellatorOutputPrimitive enum value).</td>
</tr>
<tr><td>6</td>
<td>float</td>
<td>Max tessellation factor.</td>
</tr>
</tbody>
</table>
<a name="compute-shader"></a>
<h3><a class="toc-backref" href="#toc-entry-37">Compute Shader</a></h3>
<p>Compute shader has the following tag-value properties.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="25%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Tag</th>
<th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>kDxilNumThreadsTag(4)</td>
<td>MD list: (i32, i32, i32)</td>
<td>Number of threads (X,Y,Z) for compute shader.</td>
</tr>
<tr><td>kDxilWaveSizeTag</td>
<td>MD list: (i32)</td>
<td>Wave size the shader is compatible with (optional).</td>
</tr>
</tbody>
</table>
<a name="shader-parameters-and-signatures"></a>
<h2><a class="toc-backref" href="#toc-entry-38">Shader Parameters and Signatures</a></h2>
<p>This section formalizes how HLSL shader input and output parameters are expressed in DXIL.</p>
<a name="hlsl-signatures-and-semantics"></a>
<h3><a class="toc-backref" href="#toc-entry-39">HLSL signatures and semantics</a></h3>
<p>Formal parameters of a shader entry function in HLSL specify how the shader interacts with the graphics pipeline. Input parameters, referred to as an input signature, specify values received by the shader. Output parameters, referred to as an output signature, specify values produced by the shader. The shader compiler maps HLSL input and output signatures into DXIL specifications that conform to hardware constraints outlined in the Direct3D Functional Specification. DXIL specifications are also called signatures.</p>
<p>Signature mapping is a complex process, as there are many constraints. All signature parameters must fit into a finite space of N 4x32-bit registers. For efficiency reasons, parameters are packed together in a way that does not violate specification constraints. The process is called signature packing. Most signatures are tightly packed; however, the VS input signature is not packed, as the values are coming from the Input Assembler (IA) stage rather than the graphics pipeline. Alternately, the PS output signature is allocated to align the SV_Target semantic index with the output register index.</p>
<p>Each HLSL signature parameter is defined via C-like type, interpolation mode, and semantic name and index. The type defines parameter shape, which may be quite complex. Interpolation mode adds to the packing constraints, namely that parameters packed together must have compatible interpolation modes. Semantics are extra names associated with parameters for the following purposes: (1) to specify whether a parameter is as a special System Value (SV) or not, (2) to link parameters to IA or StreamOut API streams, and (3) to aid debugging. Semantic index is used to disambiguate parameters that use the same semantic name, or span multiple rows of the register space.</p>
<p>SV semantics add specific meanings and constraints to associated parameters. A parameter may be supplied by the hardware, and is then known as a System Generated Value (SGV). Alternatively, a parameter may be interpreted by the hardware and is then known as System Interpreted Value (SIV).  SGVs and SIVs are pipeline-stage dependent; moreover, some participate in signature packing and some do not. Non-SV semantics always participate in signature packing.</p>
<p>Most System Generated Values (SGV) are loaded using special Dxil intrinsic functions, rather than loading the input from a signature.  These usually will not be present in the signature at all.  Their presence may be detected by the declaration and use of the special instrinsic function itself.  The exceptions to this are notible.  In one case they are present and loaded from the signature instead of a special intrinsic because they must be part of the packed signature potentially passed from the prior stage, allowing the prior stage to override these values, such as for SV_PrimitiveID and SV_IsFrontFace that may be written in the the Geometry Shader.  In another case, they identify signature elements that still contribute to DXBC signature for informational purposes, but will only use the special intrinsic function to read the value, such as for SV_PrimitiveID for GS input and SampleIndex for PS input.</p>
<p>The classification of behavior for various system values in various signature locations is described in a table organized by SemanticKind and SigPointKind.  The SigPointKind is a new classification that uniquely identifies each set of parameters that may be input or output for each entry point.  For each combination of SemanticKind and SigPointKind, there is a SemanticInterpretationKind that defines the class of treatment for that location.</p>
<p>Each SigPointKind also has a corresponding element allocation (or packing) behavior called PackingKind.  Some SigPointKinds do not result in a signature at all, which corresponds to the packing kind of PackingKind::None.</p>
<p>Signature Points are enumerated as follows in the SigPointKind</p>
<table class="docutils">
<colgroup>
<col width="1%" />
<col width="6%" />
<col width="5%" />
<col width="10%" />
<col width="10%" />
<col width="12%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">ID</th>
<th class="head">SigPoint</th>
<th class="head">Related</th>
<th class="head">ShaderKind</th>
<th class="head">PackingKind</th>
<th class="head">SignatureKind</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>VSIn</td>
<td>Invalid</td>
<td>Vertex</td>
<td>InputAssembler</td>
<td>Input</td>
<td>Ordinary Vertex Shader input from Input Assembler</td>
</tr>
<tr><td>1</td>
<td>VSOut</td>
<td>Invalid</td>
<td>Vertex</td>
<td>Vertex</td>
<td>Output</td>
<td>Ordinary Vertex Shader output that may feed Rasterizer</td>
</tr>
<tr><td>2</td>
<td>PCIn</td>
<td>HSCPIn</td>
<td>Hull</td>
<td>None</td>
<td>Invalid</td>
<td>Patch Constant function non-patch inputs</td>
</tr>
<tr><td>3</td>
<td>HSIn</td>
<td>HSCPIn</td>
<td>Hull</td>
<td>None</td>
<td>Invalid</td>
<td>Hull Shader function non-patch inputs</td>
</tr>
<tr><td>4</td>
<td>HSCPIn</td>
<td>Invalid</td>
<td>Hull</td>
<td>Vertex</td>
<td>Input</td>
<td>Hull Shader patch inputs - Control Points</td>
</tr>
<tr><td>5</td>
<td>HSCPOut</td>
<td>Invalid</td>
<td>Hull</td>
<td>Vertex</td>
<td>Output</td>
<td>Hull Shader function output - Control Point</td>
</tr>
<tr><td>6</td>
<td>PCOut</td>
<td>Invalid</td>
<td>Hull</td>
<td>PatchConstant</td>
<td>PatchConstOrPrim</td>
<td>Patch Constant function output - Patch Constant data passed to Domain Shader</td>
</tr>
<tr><td>7</td>
<td>DSIn</td>
<td>Invalid</td>
<td>Domain</td>
<td>PatchConstant</td>
<td>PatchConstOrPrim</td>
<td>Domain Shader regular input - Patch Constant data plus system values</td>
</tr>
<tr><td>8</td>
<td>DSCPIn</td>
<td>Invalid</td>
<td>Domain</td>
<td>Vertex</td>
<td>Input</td>
<td>Domain Shader patch input - Control Points</td>
</tr>
<tr><td>9</td>
<td>DSOut</td>
<td>Invalid</td>
<td>Domain</td>
<td>Vertex</td>
<td>Output</td>
<td>Domain Shader output - vertex data that may feed Rasterizer</td>
</tr>
<tr><td>10</td>
<td>GSVIn</td>
<td>Invalid</td>
<td>Geometry</td>
<td>Vertex</td>
<td>Input</td>
<td>Geometry Shader vertex input - qualified with primitive type</td>
</tr>
<tr><td>11</td>
<td>GSIn</td>
<td>GSVIn</td>
<td>Geometry</td>
<td>None</td>
<td>Invalid</td>
<td>Geometry Shader non-vertex inputs (system values)</td>
</tr>
<tr><td>12</td>
<td>GSOut</td>
<td>Invalid</td>
<td>Geometry</td>
<td>Vertex</td>
<td>Output</td>
<td>Geometry Shader output - vertex data that may feed Rasterizer</td>
</tr>
<tr><td>13</td>
<td>PSIn</td>
<td>Invalid</td>
<td>Pixel</td>
<td>Vertex</td>
<td>Input</td>
<td>Pixel Shader input</td>
</tr>
<tr><td>14</td>
<td>PSOut</td>
<td>Invalid</td>
<td>Pixel</td>
<td>Target</td>
<td>Output</td>
<td>Pixel Shader output</td>
</tr>
<tr><td>15</td>
<td>CSIn</td>
<td>Invalid</td>
<td>Compute</td>
<td>None</td>
<td>Invalid</td>
<td>Compute Shader input</td>
</tr>
<tr><td>16</td>
<td>MSIn</td>
<td>Invalid</td>
<td>Mesh</td>
<td>None</td>
<td>Invalid</td>
<td>Mesh Shader input</td>
</tr>
<tr><td>17</td>
<td>MSOut</td>
<td>Invalid</td>
<td>Mesh</td>
<td>Vertex</td>
<td>Output</td>
<td>Mesh Shader vertices output</td>
</tr>
<tr><td>18</td>
<td>MSPOut</td>
<td>Invalid</td>
<td>Mesh</td>
<td>Vertex</td>
<td>PatchConstOrPrim</td>
<td>Mesh Shader primitives output</td>
</tr>
<tr><td>19</td>
<td>ASIn</td>
<td>Invalid</td>
<td>Amplification</td>
<td>None</td>
<td>Invalid</td>
<td>Amplification Shader input</td>
</tr>
</tbody>
</table>
<p>Semantic Interpretations are as follows (SemanticInterpretationKind)</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="14%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">ID</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>NA</td>
<td>Not Available</td>
</tr>
<tr><td>1</td>
<td>SV</td>
<td>Normal System Value</td>
</tr>
<tr><td>2</td>
<td>SGV</td>
<td>System Generated Value (sorted last)</td>
</tr>
<tr><td>3</td>
<td>Arb</td>
<td>Treated as Arbitrary</td>
</tr>
<tr><td>4</td>
<td>NotInSig</td>
<td>Not included in signature (intrinsic access)</td>
</tr>
<tr><td>5</td>
<td>NotPacked</td>
<td>Included in signature, but does not contribute to packing</td>
</tr>
<tr><td>6</td>
<td>Target</td>
<td>Special handling for SV_Target</td>
</tr>
<tr><td>7</td>
<td>TessFactor</td>
<td>Special handling for tessellation factors</td>
</tr>
<tr><td>8</td>
<td>Shadow</td>
<td>Shadow element must be added to a signature for compatibility</td>
</tr>
<tr><td>8</td>
<td>ClipCull</td>
<td>Special packing rules for SV_ClipDistance or SV_CullDistance</td>
</tr>
</tbody>
</table>
<p>Semantic Interpretations for each SemanticKind at each SigPointKind are as follows</p>
<table class="docutils">
<colgroup>
<col width="10%" />
<col width="6%" />
<col width="4%" />
<col width="6%" />
<col width="6%" />
<col width="4%" />
<col width="4%" />
<col width="5%" />
<col width="6%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
<col width="6%" />
<col width="4%" />
<col width="6%" />
<col width="6%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Semantic</th>
<th class="head">VSIn</th>
<th class="head">VSOut</th>
<th class="head">PCIn</th>
<th class="head">HSIn</th>
<th class="head">HSCPIn</th>
<th class="head">HSCPOut</th>
<th class="head">PCOut</th>
<th class="head">DSIn</th>
<th class="head">DSCPIn</th>
<th class="head">DSOut</th>
<th class="head">GSVIn</th>
<th class="head">GSIn</th>
<th class="head">GSOut</th>
<th class="head">PSIn</th>
<th class="head">PSOut</th>
<th class="head">CSIn</th>
<th class="head">MSIn</th>
<th class="head">MSOut</th>
<th class="head">MSPOut</th>
<th class="head">ASIn</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Arbitrary</td>
<td>Arb</td>
<td>Arb</td>
<td>NA</td>
<td>NA</td>
<td>Arb</td>
<td>Arb</td>
<td>Arb</td>
<td>Arb</td>
<td>Arb</td>
<td>Arb</td>
<td>Arb</td>
<td>NA</td>
<td>Arb</td>
<td>Arb</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>Arb</td>
<td>Arb</td>
<td>NA</td>
</tr>
<tr><td>VertexID</td>
<td>SV</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>InstanceID</td>
<td>SV</td>
<td>Arb</td>
<td>NA</td>
<td>NA</td>
<td>Arb</td>
<td>Arb</td>
<td>NA</td>
<td>NA</td>
<td>Arb</td>
<td>Arb</td>
<td>Arb</td>
<td>NA</td>
<td>Arb</td>
<td>Arb</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>Position</td>
<td>Arb</td>
<td>SV</td>
<td>NA</td>
<td>NA</td>
<td>SV</td>
<td>SV</td>
<td>Arb</td>
<td>Arb</td>
<td>SV</td>
<td>SV</td>
<td>SV</td>
<td>NA</td>
<td>SV</td>
<td>SV</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>SV</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>RenderTargetArrayIndex</td>
<td>Arb</td>
<td>SV</td>
<td>NA</td>
<td>NA</td>
<td>SV</td>
<td>SV</td>
<td>Arb</td>
<td>Arb</td>
<td>SV</td>
<td>SV</td>
<td>SV</td>
<td>NA</td>
<td>SV</td>
<td>SV</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>SV</td>
<td>NA</td>
</tr>
<tr><td>ViewPortArrayIndex</td>
<td>Arb</td>
<td>SV</td>
<td>NA</td>
<td>NA</td>
<td>SV</td>
<td>SV</td>
<td>Arb</td>
<td>Arb</td>
<td>SV</td>
<td>SV</td>
<td>SV</td>
<td>NA</td>
<td>SV</td>
<td>SV</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>SV</td>
<td>NA</td>
</tr>
<tr><td>ClipDistance</td>
<td>Arb</td>
<td>ClipCull</td>
<td>NA</td>
<td>NA</td>
<td>ClipCull</td>
<td>ClipCull</td>
<td>Arb</td>
<td>Arb</td>
<td>ClipCull</td>
<td>ClipCull</td>
<td>ClipCull</td>
<td>NA</td>
<td>ClipCull</td>
<td>ClipCull</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>ClipCull</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>CullDistance</td>
<td>Arb</td>
<td>ClipCull</td>
<td>NA</td>
<td>NA</td>
<td>ClipCull</td>
<td>ClipCull</td>
<td>Arb</td>
<td>Arb</td>
<td>ClipCull</td>
<td>ClipCull</td>
<td>ClipCull</td>
<td>NA</td>
<td>ClipCull</td>
<td>ClipCull</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>ClipCull</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>OutputControlPointID</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>DomainLocation</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>PrimitiveID</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>Shadow</td>
<td>SGV</td>
<td>SGV</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>SV</td>
<td>NA</td>
</tr>
<tr><td>GSInstanceID</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>SampleIndex</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>Shadow _41</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>IsFrontFace</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>SGV</td>
<td>SGV</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>Coverage</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig _50</td>
<td>NotPacked _41</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>InnerCoverage</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig _50</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>Target</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>Target</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>Depth</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotPacked</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>DepthLessEqual</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotPacked _50</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>DepthGreaterEqual</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotPacked _50</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>StencilRef</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotPacked _50</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>DispatchThreadID</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
</tr>
<tr><td>GroupID</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
</tr>
<tr><td>GroupIndex</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
</tr>
<tr><td>GroupThreadID</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
</tr>
<tr><td>TessFactor</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>TessFactor</td>
<td>TessFactor</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>InsideTessFactor</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>TessFactor</td>
<td>TessFactor</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>ViewID</td>
<td>NotInSig _61</td>
<td>NA</td>
<td>NotInSig _61</td>
<td>NotInSig _61</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig _61</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig _61</td>
<td>NA</td>
<td>NotInSig _61</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>Barycentrics</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotPacked _61</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>ShadingRate</td>
<td>NA</td>
<td>SV _64</td>
<td>NA</td>
<td>NA</td>
<td>SV _64</td>
<td>SV _64</td>
<td>NA</td>
<td>NA</td>
<td>SV _64</td>
<td>SV _64</td>
<td>SV _64</td>
<td>NA</td>
<td>SV _64</td>
<td>SV _64</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>SV</td>
<td>NA</td>
</tr>
<tr><td>CullPrimitive</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotInSig</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NotPacked</td>
<td>NA</td>
</tr>
<tr><td>StartVertexLocation</td>
<td>NotInSig _68</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr><td>StartInstanceLocation</td>
<td>NotInSig _68</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
</tbody>
</table>
<p>Below is a vertex shader example that is used for illustration throughout this section:</p>
<pre>
struct Foo {
  float a;
  float b[2];
};

struct VSIn {
  uint    vid     : SV_VertexID;
  float3  pos     : Position;
  Foo     foo[3]  : SemIn1;
  float   f       : SemIn10;
};

struct VSOut
{
  float   f       : SemOut1;
  Foo     foo[3]  : SemOut2;
  float4  pos     : SV_Position;
};

void main(in  VSIn  In,        // input  signature
          out VSOut Out)       // output signature
{
  ...
}
</pre>
<p>Signature packing must be efficient. It should use as few registers as possible, and the packing algorithm should run in reasonable time. The complication is that the problem is NP complete, and the algorithm needs to resort to using a heuristic.</p>
<p>While the details of the packing algorithm are not important at the moment, it is important to outline some concepts related to how a packed signature is represented in DXIL. Packing is further complicated by the complexity of parameter shapes induced by the C/C++ type system. In the example above, fields of Out.foo array field are actually arrays themselves, strided in memory. Allocating such strided shapes efficiently is hard. To simplify packing, the first step is to break user-defined (struct) parameters into constituent components and to make strided arrays contiguous. This preparation step enables the algorithm to operate on dense rectangular shapes, which we call signature elements. The output signature in the example above has the following elements: float Out_f, float Out_foo_a[3], float Out_foo_b[2][3], and float4 pos. Each element is characterized by the number of rows and columns. These are 1x1, 3x1, 6x1, and 1x4, respectively. The packing algorithm reduces to fitting these elements into Nx4 register space, satisfying all packing-compatibility constraints.</p>
<a name="signature-element-record"></a>
<h3><a class="toc-backref" href="#toc-entry-40">Signature element record</a></h3>
<p>Each signature element is represented in DXIL as a metadata record.</p>
<p>For above example output signature, the element records are as follows:</p>
<pre>
;  element ID, semantic name, etype, sv, s.idx, interp,  rows, cols, start row, col, ext. list
!20 = !{i32 6, !&quot;SemOut&quot;,      i8 0, i8 0, !40,   i8 2, i32 1, i8 1, i32 1,    i8 2, null}
!21 = !{i32 7, !&quot;SemOut&quot;,      i8 0, i8 0, !41,   i8 2, i32 3, i8 1, i32 1,    i8 1, null}
!22 = !{i32 8, !&quot;SemOut&quot;,      i8 0, i8 0, !42,   i8 2, i32 6, i8 1, i32 1,    i8 0, null}
!23 = !{i32 9, !&quot;SV_Position&quot;, i8 0, i8 3, !43,   i8 2, i32 1, i8 4, i32 0,    i8 0, null}
</pre>
<p>A record contains the following fields.</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="15%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>i32</td>
<td>Unique signature element record ID, used to identify the element in operations.</td>
</tr>
<tr><td>1</td>
<td>String metadata</td>
<td>Semantic name.</td>
</tr>
<tr><td>2</td>
<td>i8</td>
<td>ComponentType (enum value).</td>
</tr>
<tr><td>3</td>
<td>i8</td>
<td>SemanticKind (enum value).</td>
</tr>
<tr><td>4</td>
<td>Metadata</td>
<td>Metadata list that enumerates all semantic indexes of the flattened parameter.</td>
</tr>
<tr><td>5</td>
<td>i8</td>
<td>InterpolationMode (enum value).</td>
</tr>
<tr><td>6</td>
<td>i32</td>
<td>Number of element rows.</td>
</tr>
<tr><td>7</td>
<td>i8</td>
<td>Number of element columns.</td>
</tr>
<tr><td>8</td>
<td>i32</td>
<td>Starting row of element packing location.</td>
</tr>
<tr><td>9</td>
<td>i8</td>
<td>Starting column of element packing location.</td>
</tr>
<tr><td>10</td>
<td>Metadata</td>
<td>Metadata list of additional tag-value pairs; can be 'null' or empty.</td>
</tr>
</tbody>
</table>
<p>Semantic name system values always start with 'S', 'V', '_' , and it is illegal to start a user semantic with this prefix. Non-SVs can be ignored by drivers. Debug layers may use these to help validate signature compatibility between stages.</p>
<p>The last metadata list is used to specify additional properties and future extensions.</p>
<a name="signature-record-metadata"></a>
<h3><a class="toc-backref" href="#toc-entry-41">Signature record metadata</a></h3>
<p>A shader typically has two signatures: input and output, while domain shader has an additional patch constant signature. The signatures are composed of signature element records and are attached to the shader entry metadata. The examples below clarify metadata details.</p>
<a name="vertex-shader-hlsl"></a>
<h4>Vertex shader HLSL</h4>
<p>Here is the HLSL of the above vertex shader. The semantic index assignment is explained in section below:</p>
<pre>
struct Foo
{
  float a;
  float b[2];
};

struct VSIn
{
  uint    vid     : SV_VertexID;
  float3  pos     : Position;
  Foo     foo[3]  : SemIn1;
    // semantic index assignment:
    // foo[0].a     : SemIn1
    // foo[0].b[0]  : SemIn2
    // foo[0].b[1]  : SemIn3
    // foo[1].a     : SemIn4
    // foo[1].b[0]  : SemIn5
    // foo[1].b[1]  : SemIn6
    // foo[2].a     : SemIn7
    // foo[2].b[0]  : SemIn8
    // foo[2].b[1]  : SemIn9
  float   f       : SemIn10;
};

struct VSOut
{
  float   f       : SemOut1;
  Foo     foo[3]  : SemOut2;
    // semantic index assignment:
    // foo[0].a     : SemOut2
    // foo[0].b[0]  : SemOut3
    // foo[0].b[1]  : SemOut4
    // foo[1].a     : SemOut5
    // foo[1].b[0]  : SemOut6
    // foo[1].b[1]  : SemOut7
    // foo[2].a     : SemOut8
    // foo[2].b[0]  : SemOut9
    // foo[2].b[1]  : SemOut10
  float4  pos     : SV_Position;
};

void main(in  VSIn  In,        // input  signature
          out VSOut Out)       // output signature
{
  ...
}
</pre>
<p>The input signature is packed to be compatible with the IA stage. A packing algorithm must assign the following starting positions to the input signature elements:</p>
<table class="docutils">
<colgroup>
<col width="37%" />
<col width="8%" />
<col width="14%" />
<col width="18%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Input element</th>
<th class="head">Rows</th>
<th class="head">Columns</th>
<th class="head">Start row</th>
<th class="head">Start column</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>uint VSIn.vid</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr><td>float3 VSIn.pos</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>0</td>
</tr>
<tr><td>float VSIn.foo.a[3]</td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
<tr><td>float VSIn.foo.b[6]</td>
<td>6</td>
<td>1</td>
<td>5</td>
<td>0</td>
</tr>
<tr><td>float VSIn.f</td>
<td>1</td>
<td>1</td>
<td>11</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>A reasonable packing algorithm would assign the following starting positions to the output signature elements:</p>
<table class="docutils">
<colgroup>
<col width="38%" />
<col width="8%" />
<col width="13%" />
<col width="17%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Input element</th>
<th class="head">Rows</th>
<th class="head">Columns</th>
<th class="head">Start row</th>
<th class="head">Start column</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>uint VSOut.f</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr><td>float VSOut.foo.a[3]</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr><td>float VSOut.foo.b[6]</td>
<td>6</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr><td>float VSOut.pos</td>
<td>1</td>
<td>4</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<a name="semantic-index-assignment"></a>
<h4>Semantic index assignment</h4>
<p>Semantic index assignment in DXIL is exactly the same as for DXBC. Semantic index assignment, abbreviated s.idx above, is a consecutive enumeration of all fields under the same semantic name as if the signature were packed for the IA stage. That is, given a complex signature element, e.g., VSOut's foo[3] with semantic name SemOut and starting index 2, the element is flattened into individual fields: foo[0].a, foo[0].b[0], ..., foo[2].b[1], and the fields receive consecutive semantic indexes 2, 3, ..., 10, respectively. Semantic-index pairs are used to set up the IA stage and to capture values of individual signature registers via the StreamOut API.</p>
<a name="dxil-for-vs-signatures"></a>
<h4>DXIL for VS signatures</h4>
<p>The corresponding DXIL metadata is presented below:</p>
<pre>
!dx.entryPoints = !{ !1 }
!1 = !{ void &#64;main(), !&quot;main&quot;, !2, null, null }
; Signatures: In,   Out,  Patch Constant (optional)
!2 = !{       !3,   !4,   null }

; Input signature (packed accordiong to IA rules)
!3 = !{ !10, !11, !12, !13, !14 }
; element idx, semantic name, etype, sv, s.idx, interp,  rows, cols, start row, col, ext. list
!10 = !{i32 1, !&quot;SV_VertexID&quot;, i8 0, i8 1, !30,  i32 0, i32 1, i8 1, i32 0,    i8 0, null}
!11 = !{i32 2, !&quot;Position&quot;,    i8 0, i8 0, !30,  i32 0, i32 1, i8 3, i32 1,    i8 0, null}
!12 = !{i32 3, !&quot;SemIn&quot;,       i8 0, i8 0, !32,  i32 0, i32 3, i8 1, i32 2,    i8 0, null}
!13 = !{i32 4, !&quot;SemIn&quot;,       i8 0, i8 0, !33,  i32 0, i32 6, i8 1, i32 5,    i8 0, null}
!14 = !{i32 5, !&quot;SemIn&quot;,       i8 0, i8 0, !34,  i32 0, i32 1, i8 1, i32 11,   i8 0, null}
; semantic index assignment:
!30 = !{ i32 0 }
!32 = !{ i32 1, i32 4, i32 7 }
!33 = !{ i32 2, i32 3, i32 5, i32 6, i32 8, i32 9 }
!34 = !{ i32 10 }

; Output signature (tightly packed according to pipeline stage packing rules)
!4 = !{ !20, !21, !22, !23 }
;  element ID, semantic name, etype, sv, s.idx, interp,  rows, cols, start row, col, ext. list
!20 = !{i32 6, !&quot;SemOut&quot;,      i8 0, i8 0, !40,  i32 2, i32 1, i8 1, i32 1,    i8 2, null}
!21 = !{i32 7, !&quot;SemOut&quot;,      i8 0, i8 0, !41,  i32 2, i32 3, i8 1, i32 1,    i8 1, null}
!22 = !{i32 8, !&quot;SemOut&quot;,      i8 0, i8 0, !42,  i32 2, i32 6, i8 1, i32 1,    i8 0, null}
!23 = !{i32 9, !&quot;SV_Position&quot;, i8 0, i8 3, !43,  i32 2, i32 1, i8 4, i32 0,    i8 0, null}
; semantic index assignment:
!40 = !{ i32 1 }
!41 = !{ i32 2, i32 5, i32 8 }
!42 = !{ i32 3, i32 4, i32 6, i32 7, i32 9, i32 10 }
!43 = !{ i32 0 }
</pre>
<a name="hull-shader-example"></a>
<h4>Hull shader example</h4>
<p>A hull shader (HS) is defined by two entry point functions: control point (CP) function to compute control points, and patch constant (PC) function to compute patch constant data, including the tessellation factors. The inputs to both functions are the input control points for an entire patch, and therefore each element may be indexed by row and, in addition, is indexed by vertex.</p>
<p>Here is an HS example entry point metadata and signature list:</p>
<pre>
; !105 is extended parameter list containing reference to HS State:
!101 = !{ void &#64;HSMain(), !&quot;HSMain&quot;, !102, null, !105 }
; Signatures: In,   Out,  Patch Constant
!102 = !{     !103, !104, !204 }
</pre>
<p>The entry point record specifies: (1) CP function HSMain as the main symbol, and (2) PC function via optional metadata node !105.</p>
<p>CP-input signature describing one input control point:</p>
<pre>
!103 = !{ !110, !111 }
;  element ID, semantic name, etype, sv, s.idx, interp,  rows, cols, start row, col, ext. list
!110= !{i32 1, !&quot;SV_Position&quot;, i8 0, i8 3, !130, i32 0, i32 1, i8 4, i32 0,    i8 0, null}
!111= !{i32 2, !&quot;array&quot;,       i8 0, i8 0, !131, i32 0, i32 4, i8 3, i32 1,    i8 0, null}
; semantic indexing for flattened elements:
!130 = !{ i32 0 }
!131 = !{ i32 0, i32 1, i32 2, i32 3 }
</pre>
<p>Note that SV_OutputControlPointID and SV_PrimitiveID input elements are SGVs loaded through special Dxil intrinsics, and are not present in the signature at all.  These have a semantic interpretation of SemanticInterpretationKind::NotInSig.</p>
<p>CP-output signature describing one output control point:</p>
<pre>
!104 = !{ !120, !121 }
;  element ID, semantic name, etype, sv, s.idx, interp,  rows, cols, start row, col, ext. list
!120= !{i32 3, !&quot;SV_Position&quot;, i8 0, i8 3, !130, i32 0, i32 1, i8 4, i32 0,    i8 0, null}
!121= !{i32 4, !&quot;array&quot;,       i8 0, i8 0, !131, i32 0, i32 4, i8 3, i32 1,    i8 0, null}
</pre>
<p>Hull shaders require an extended parameter that defines extra state:</p>
<pre>
; extended parameter HS State
!105 = !{ i32 3, !201 }

; HS State record defines patch constant function and other properties
; Patch Constant Function, in CP count, out CP count, tess domain, tess part, out prim, max tess factor
!201 = !{  void &#64;PCMain(), 4,           4,            3,           1,         3,        16.0 }
</pre>
<p>PC-output signature:</p>
<pre>
!204 = !{ !220, !221, !222 }
;  element ID, semantic name,         etype,   sv, s.idx,  interp, rows, cols, start row, col, ext. list
!220= !{i32 3, !&quot;SV_TessFactor&quot;,       i8 0, i8 25, !130,  i32 0, i32 4, i8 1, i32 0, i8 3, null}
!221= !{i32 4, !&quot;SV_InsideTessFactor&quot;, i8 0, i8 26, !231,  i32 0, i32 2, i8 1, i32 4, i8 3, null}
!222= !{i32 5, !&quot;array&quot;,               i8 0, i8 0,  !131,  i32 0, i32 4, i8 3, i32 0, i8 0, null}
; semantic indexing for flattened elements:
!231 = !{ i32 0, i32 1 }
</pre>
<a name="accessing-signature-value-in-operations"></a>
<h3><a class="toc-backref" href="#toc-entry-42">Accessing signature value in operations</a></h3>
<p>There are no function parameters or variables that correspond to signature elements. Instead loadInput and storeOutput functions are used to access signature element values in operations. The accesses are scalar.</p>
<p>These are the operation signatures:</p>
<pre>
; overloads: SM5.1: f16|f32|i16|i32,  SM6.0: f16|f32|f64|i8|i16|i32|i64
declare float &#64;dx.op.loadInput.f32(
    i32,                            ; opcode
    i32,                            ; input ID
    i32,                            ; row (relative to start row of input ID)
    i8,                             ; column (relative to start column of input ID), constant in [0,3]
    i32)                            ; vertex index

; overloads: SM5.1: f16|f32|i16|i32,  SM6.0: f16|f32|f64|i8|i16|i32|i64
declare void &#64;dx.op.storeOutput.f32(
    i32,                            ; opcode
    i32,                            ; output ID
    i32,                            ; row (relative to start row of output ID)
    i8,                             ; column (relative to start column of output ID), constant in [0,3]
    float)                          ; value to store
</pre>
<p>LoadInput/storeOutput takes input/output element ID, which is the unique ID of a signature element metadata record. The row parameter is the array element row index from the start of the element; the register index is obtained by adding the start row of the element and the row parameter value. Similarly, the column parameter is relative column index; the packed register component is obtained by adding the start component of the element (packed col) and the column value. Several overloads exist to access elements of different primitive types. LoadInput takes an additional vertex index parameter that represents vertex index for DS CP-inputs and GS inputs; vertex index must be undef in other cases.</p>
<a name="signature-packing"></a>
<h3><a class="toc-backref" href="#toc-entry-43">Signature packing</a></h3>
<p>Signature elements must be packed into a space of N 4-32-bit registers according to runtime constraints. DXIL contains packed signatures. The packing algorithm is more aggressive than that for DX11. However, DXIL packing is only a suggestion to the driver implementation. Driver compilers can rearrange signature elements as they see fit, while preserving compatibility of connected pipeline stages. DXIL is designed in such a way that it is easy to 'relocate' signature elements - loadInput/storeOutput row and column indices do not need to change since they are relative to the start row/column for each element.</p>
<a name="signature-packing-types"></a>
<h4>Signature packing types</h4>
<p>Two pipeline stages can connect in four different ways, resulting in four packing types.</p>
<ol class="arabic simple">
<li>Input Assembly: VS input only
* Elements all map to unique registers, they may not be packed together.
* Interpolation mode is not used.</li>
<li>Connects to Rasterizer: VS output, HS CP-input/output and PC-input, DS CP-input/output, GS input/output, PS input
* Elements can be packed according to constraints.
* Interpolation mode is used and must be consistent between connecting signatures.
* While HS CP-output and DS CP-input signatures do not go through the rasterizer, they are still treated as such. The reason is the pass-through HS case, in which HS CP-input and HS CP-output must have identical packing for efficiency.</li>
<li>Patch Constant: HS PC-output, DS PC-input
* SV_TessFactor and SV_InsideTessFactor are the only SVs relevant here, and this is the only location where they are legal. These have special packing considerations.
* Interpolation mode is not used.</li>
<li>Pixel Shader Output: PS output only
* Only SV_Target maps to output register space.
* No packing is performed, semantic index corresponds to render target index.</li>
</ol>
<a name="packing-constraints"></a>
<h4>Packing constraints</h4>
<p>The packing algorithm is stricter and more aggressive in DXIL than in DXBC, although still compatible. In particular, array signature elements are not broken up into scalars, even if each array access can be disambiguated to a literal index. DXIL and DXBC signature packing are not identical, so linking them together into a single pipeline is not supported across compiler generations.</p>
<p>The row dimension of a signature element represents an index range. If constraints permit, two adjacent or overlapping index ranges are coalesced into a single index range.</p>
<p>Packing constraints are as follows:</p>
<ol class="arabic simple">
<li>A register must have only one interpolation mode for all 4 components.</li>
<li>Register components containing SVs must be to the right of components containing non-SVs.</li>
<li>SV_ClipDistance and SV_CullDistance have additional constraints:
a. May be packed together
b. Must occupy a maximum of 2 registers (8-components)
c. SV_ClipDistance must have linear interpolation mode</li>
<li>Registers containing SVs may not be within an index range, with the exception of Tessellation Factors (TessFactors).</li>
<li>If an index range R1 overlaps with a TessFactor index range R2, R1 must be contained within R2. As a consequence, outside and inside TessFactors occupy disjoint index ranges when packed.</li>
<li>Non-TessFactor index ranges are combined into a larger range, if they overlap.</li>
<li>SGVs must be packed after all non-SGVs have been packed. If there are several SGVs, they are packed in the order of HLSL declaration.</li>
</ol>
<a name="packing-for-sgvs"></a>
<h4>Packing for SGVs</h4>
<p>Non-SGV portions of two connecting signatures must match; however, SGV portions don't have to. An example would be a PS declaring SV_PrimitiveID as an input. If VS connects to PS, PS's SV_PrimitiveID value is synthesized by hardware; moreover, it is illegal to output SV_PrimitiveID from a VS. If GS connects PS, GS may declare SV_PrimitiveID as its output.</p>
<p>Unfortunately, SGV specification creates a complication for separate compilation of connecting shaders. For example, GS outputs SV_PrimitiveID, and PS inputs SV_IsFrontFace and SV_PrimitiveID in this order. The positions of SV_PrimitiveID are incompatible in GS and PS signatures. Not much can be done about this ambiguity in SM5.0 and earlier; the programmers will have to rely on SDKLayers to catch potential mismatch.</p>
<p>SM5.1 and later shaders work on D3D12+ runtime that uses PSO objects to describe pipeline state. Therefore, a driver compiler has access to both connecting shaders during compilation, even though the HLSL compiler does not. The driver compiler can resolve SGV ambiguity in signatures easily. For SM5.1 and later, the HLSL compiler will ensure that declared SGVs fit into packed signature; however, it will set SGV's start row-column location to (-1, 0) such that the driver compiler must resolve SGV placement during PSO compilation.</p>
<a name="shader-resources"></a>
<h2><a class="toc-backref" href="#toc-entry-44">Shader Resources</a></h2>
<p>All global resources referenced by entry points of an LLVM module are described via named metadata dx.resources, which consists of four metadata lists of resource records:</p>
<pre>
!dx.resources = !{ !1, !2, !3, !4 }
</pre>
<p>Resource lists are as follows.</p>
<table class="docutils">
<colgroup>
<col width="7%" />
<col width="20%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>Metadata</td>
<td>SRVs - shader resource views.</td>
</tr>
<tr><td>1</td>
<td>Metadata</td>
<td>UAVs - unordered access views.</td>
</tr>
<tr><td>2</td>
<td>Metadata</td>
<td>CBVs - constant buffer views.</td>
</tr>
<tr><td>3</td>
<td>Metadata</td>
<td>Samplers.</td>
</tr>
</tbody>
</table>
<a name="metadata-resource-records"></a>
<h3><a class="toc-backref" href="#toc-entry-45">Metadata resource records</a></h3>
<p>Each resource list contains resource records. Each resource record contains fields that are common for each resource type, followed by fields specific to each resource type, followed by a metadata list of tag/value pairs, which can be used to specify additional properties or future extensions and may be null or empty.</p>
<p>Common fields:</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="14%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>i32</td>
<td>Unique resource record ID, used to identify the resource record in createHandle operation.</td>
</tr>
<tr><td>1</td>
<td>Pointer</td>
<td>Pointer to a global constant symbol with the original shape of resource and element type.</td>
</tr>
<tr><td>2</td>
<td>Metadata string</td>
<td>Name of resource variable.</td>
</tr>
<tr><td>3</td>
<td>i32</td>
<td>Bind space ID of the root signature range that corresponds to this resource.</td>
</tr>
<tr><td>4</td>
<td>i32</td>
<td>Bind lower bound of the root signature range that corresponds to this resource.</td>
</tr>
<tr><td>5</td>
<td>i32</td>
<td>Range size of the root signature range that corresponds to this resource.</td>
</tr>
</tbody>
</table>
<p>When the shader has reflection information, the name is the original, unmangled HLSL name. If reflection is stripped, the name is empty string.</p>
<p>SRV-specific fields:</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="14%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>6</td>
<td>i32</td>
<td>SRV resource shape (enum value).</td>
</tr>
<tr><td>7</td>
<td>i32</td>
<td>SRV sample count.</td>
</tr>
<tr><td>8</td>
<td>Metadata</td>
<td>Metadata list of additional tag-value pairs.</td>
</tr>
</tbody>
</table>
<p>SRV-specific tag/value pairs:</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="3%" />
<col width="4%" />
<col width="49%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Tag</th>
<th class="head">Type</th>
<th class="head">Resource Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>0</td>
<td>i32</td>
<td>Any resource, except RawBuffer and StructuredBuffer</td>
<td>Element type.</td>
</tr>
<tr><td>1</td>
<td>1</td>
<td>i32</td>
<td>StructuredBuffer</td>
<td>Element stride or StructureBuffer, in bytes.</td>
</tr>
</tbody>
</table>
<p>The symbol names for the are kDxilTypedBufferElementTypeTag (0) and kDxilStructuredBufferElementStrideTag (1).</p>
<p>UAV-specific fields:</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="14%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>6</td>
<td>i32</td>
<td>UAV resource shape (enum value).</td>
</tr>
<tr><td>7</td>
<td>i1</td>
<td>1 - globally-coherent UAV; 0 - otherwise.</td>
</tr>
<tr><td>8</td>
<td>i1</td>
<td>1 - UAV has counter; 0 - otherwise.</td>
</tr>
<tr><td>9</td>
<td>i1</td>
<td>1 - UAV is ROV (rasterizer ordered view); 0 - otherwise.</td>
</tr>
<tr><td>10</td>
<td>Metadata</td>
<td>Metadata list of additional tag-value pairs.</td>
</tr>
</tbody>
</table>
<p>UAV-specific tag/value pairs:</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="3%" />
<col width="4%" />
<col width="50%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Tag</th>
<th class="head">Type</th>
<th class="head">Resource Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>0</td>
<td>i32</td>
<td>RW resource, except RWRawBuffer and RWStructuredBuffer</td>
<td>Element type.</td>
</tr>
<tr><td>1</td>
<td>1</td>
<td>i32</td>
<td>RWStructuredBuffer</td>
<td>Element stride or StructureBuffer, in bytes.</td>
</tr>
</tbody>
</table>
<p>The symbol names for the are kDxilTypedBufferElementTypeTag (0) and kDxilStructuredBufferElementStrideTag (1).</p>
<p>CBV-specific fields:</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="14%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>6</td>
<td>i32</td>
<td>Constant buffer size in bytes.</td>
</tr>
<tr><td>7</td>
<td>Metadata</td>
<td>Metadata list of additional tag-value pairs.</td>
</tr>
</tbody>
</table>
<p>Sampler-specific fields:</p>
<table class="docutils">
<colgroup>
<col width="3%" />
<col width="14%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Idx</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>6</td>
<td>i32</td>
<td>Sampler type (enum value).</td>
</tr>
<tr><td>7</td>
<td>Metadata</td>
<td>Metadata list of additional tag-value pairs.</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates SRV metadata:</p>
<pre>
; Original HLSL
; Texture2D&lt;float4&gt; MyTexture2D : register(t0, space0);
; StructuredBuffer&lt;NS1::MyType1&gt; MyBuffer[2][3] : register(t1, space0);

!1 = !{ !2, !3 }

; Scalar resource: Texture2D&lt;float4&gt; MyTexture2D.
%dx.types.ResElem.v4f32 = type { &lt;4 x float&gt; }
&#64;MyTexture2D = external addrspace(1) constant %dx.types.ResElem.v4f32, align 16
!2 = !{ i32 0, %dx.types.ResElem.v4f32 addrspace(1)* &#64;MyTexture2D, !&quot;MyTexture2D&quot;,
        i32 0, i32 0, i32 1, i32 2, i32 0, null }

; Array resource: StructuredBuffer&lt;MyType1&gt; MyBuffer[2][3].
%struct.NS1.MyType1 = type { float, &lt;2 x i32&gt; }
%dx.types.ResElem.NS1.MyType1 = type { %struct.NS1.MyType1 }
&#64;MyBuffer = external addrspace(1) constant [2x [3 x %dx.types.ResElem.NS1.MyType1]], align 16
!3 = !{ i32 1, [2 x [3 x %dx.types.ResElem.NS1.MyType1]] addrspace(1)* &#64;MyBuffer, !&quot;MyBuffer&quot;,
        i32 0, i32 1, i32 6, i32 11, i32 0, null }
</pre>
<p>The type name of the variable is constructed by appending the element name (primitive, vector or UDT name) to dx.types.ResElem prefix. The type configuration of the resource range variable conveys (1) resource range shape and (2) resource element type.</p>
<a name="reflection-information"></a>
<h3><a class="toc-backref" href="#toc-entry-46">Reflection information</a></h3>
<p>Resource reflection data is conveyed via the resource's metadata record and global, external variable. The metadata record contains the original HLSL name, root signature range information, and the reference to the global resource variable declaration. The resource variable declaration conveys resource range shape, resource type and resource element type.</p>
<p>The following disassembly provides an example:</p>
<pre>
; Scalar resource: Texture2D&lt;float4&gt; MyTexture2D.
%dx.types.ResElem.v4f32 = type { &lt;4 x float&gt; }
&#64;MyTexture2D = external addrspace(1) constant %dx.types.ResElem.v4f32, align 16
!0 = !{ i32 0, %dx.types.ResElem.v4f32 addrspace(1)* &#64;MyTexture2D, !&quot;MyTexture2D&quot;,
        i32 0, i32 3, i32 1, i32 2, i32 0, null }

; struct MyType2 { float4 field1; int2 field2; };
; Constant buffer: ConstantBuffer&lt;MyType2&gt; MyCBuffer1[][3] : register(b5, space7)
%struct.MyType2 = type { &lt;4 x float&gt;, &lt;2 x i32&gt; }
; Type reflection information (optional)
!struct.MyType2 = !{ !1, !2 }
!1 = !{ !&quot;field1&quot;, null }
!2 = !{ !&quot;field2&quot;, null }

%dx.types.ResElem.MyType1 = type { %struct.MyType2 }

&#64;MyCBuffer1 = external addrspace(1) constant [0 x [3 x %dx.types.ResElem.MyType2]], align 16

!3 = !{ i32 0, [0 x [3 x %dx.types.ResElem.MyType1]] addrspace(1)* &#64;MyCBuffer1, !&quot;MyCBuffer1&quot;,
        i32 7, i32 5, i32 -1, null }
</pre>
<p>The reflection information can be removed from DXIL by obfuscating the resource HLSL name and resource variable name as well as removing reflection type annotations, if any.</p>
<a name="structure-of-resource-operation"></a>
<h3><a class="toc-backref" href="#toc-entry-47">Structure of resource operation</a></h3>
<p>Operations involving shader resources and samplers are expressed via external function calls.</p>
<p>Below is an example for the sample method:</p>
<pre>
%dx.types.ResRet.f32 = type { float, float, float, float, i32 }

declare %dx.types.ResRet.f32 &#64;dx.op.sample.f32(
    i32,                      ; opcode
    %dx.types.ResHandle,      ; texture handle
    %dx.types.SamplerHandle,  ; sampler handle
    float,                    ; coordinate c0
    float,                    ; coordinate c1
    float,                    ; coordinate c2
    float,                    ; coordinate c3
    i32,                      ; offset o0
    i32,                      ; offset o1
    i32,                      ; offset o2
    float)                    ; clamp
</pre>
<p>The method always returns five scalar values that are aggregated in dx.types.ResRet.f32 type and extracted into scalars via LLVM's extractelement right after the call. The first four elements are sample values and the last field is the status of operation for tiled resources. Some return values may be unused, which is easily determined from the SSA form. The driver compiler is free to specialize the sample instruction to the most efficient form depending on which return values are used in computation.</p>
<p>If applicable, each intrinsic is overloaded on return type, e.g.:</p>
<pre>
%dx.types.ResRet.f32 = type { float, float, float, float, i32 }
%dx.types.ResRet.f16 = type { half, half, half, half, i32 }

declare %dx.types.ResRet.f32 &#64;dx.op.sample.f32(...)
declare %dx.types.ResRet.f16 &#64;dx.op.sample.f16(...)
</pre>
<p>Wherever applicable, the return type indicates the &quot;precision&quot; at which the operation is executed. For example, sample intrinsic that returns half data is allowed to be executed at half precision, assuming hardware supports this; however, if the return type is float, the sample operation must be executed in float precision. If lower-precision is not supported by hardware, it is allowed to execute a higher-precision variant of the operation.</p>
<p>The opcode parameter uniquely identifies the sample operation. More details can be found in the Instructions section. The value of opcode is the same for all overloads of an operation.</p>
<p>Some resource operations are &quot;polymorphic&quot; with respect to resource types, e.g., dx.op.sample.f32 operates on several resource types: Texture1D[Array], Texture2D[Array], Texture3D, TextureCUBE[Array].</p>
<p>Each resource/sampler is represented by a pair of i32 values. The first value is a unique (virtual) resource range ID, which corresponds to HLSL declaration of a resource/sampler. Range ID must be a constant for SM5.1 and below. The second integer is a 0-based index within the range. The index must be constant for SM5.0 and below.</p>
<p>Both indices can be dynamic for SM6 and later to provide flexibility in usage of resources/samplers in control flow, e.g.:</p>
<pre>
Texture2D&lt;float4&gt; a[8], b[8];
...
Texture2D&lt;float4&gt; c;
if(cond)      // arbitrary expression
  c = a[idx1];
else
  c = b[idx2];
... = c.Sample(...);
</pre>
<p>Resources/samplers used in such a way must reside in descriptor tables (cannot be root descriptors); this will be validated during shader and root signature setup.</p>
<p>The DXIL validator will ensure that all leaf-ranges (a and b above) of such a resource/sampler live-range have the same resource/sampler type and element type. If applicable, this constraint may be relaxed in the future. In particular, it is logical from HLSL programmer point of view to issue loads on compatible resource types, e.g., Texture2D, RWTexture2D, ROVTexture2D:</p>
<pre>
Texture2D&lt;float4&gt; a[8];
RWTexture2D&lt;float4&gt; b[6];
...
Texture2D&lt;float4&gt; c;
if(cond)      // arbitrary expression
 c = a[idx1];
else
 c = b[idx2];
... = c.Load(...);
</pre>
<p>LLVM's undef value is used for unused input parameters. For example, coordinates c2 and c3 in an dx.op.sample.f32 call for Texture2D are undef, as only two coordinates c0 and c1 are required.</p>
<p>If the clamp parameter is unused, its default value is 0.0f.</p>
<p>Resource operations are not overloaded on input parameter types. For example, dx.op.sample.f32 operation does not have an overload where coordinates have half, rather than float, data type. Instead, the precision of input arguments can be inferred from the IR via a straightforward lookup along an SSA edge, e.g.:</p>
<pre>
%c0 = fpext half %0 to float
%res = call %dx.types.ResRet.f32 &#64;dx.op.sample.f32(..., %c0, ...)
</pre>
<p>SSA form makes it easy to infer that value %0 of type half got promoted to float. The driver compiler can tailor the instruction to the most efficient form for the target hardware.</p>
<a name="resource-operations"></a>
<h3><a class="toc-backref" href="#toc-entry-48">Resource operations</a></h3>
<p>The section lists resource access operations. The specification is given for float return type, if applicable. The list of all overloads can be found in the appendix on intrinsic operations.</p>
<p>Some general rules to interpret resource operations:</p>
<ul class="simple">
<li>The number of active (meaningful) return components is determined by resource element type. Other return values must be unused; validator ensures this.</li>
<li>GPU instruction needs status only if the status return value is used in the program, which is determined through SSA.</li>
<li>Overload suffixes are specified for each resource operation.</li>
<li>Type of resource determines which inputs must be defined. Unused inputs are passed typed LLVM 'undef' values. This is checked by the DXIL validator.</li>
<li>Offset input parameters are i8 constants in [-8,+7] range; default offset is 0.</li>
</ul>
<a name="resource-operation-return-types"></a>
<h4>Resource operation return types</h4>
<p>Many resource operations return several scalar values as well as status for tiled resource access. The return values are grouped into a helper structure type, as this is LLVM's way to return several values from the operation. After an operation, helper types are immediately decomposed into scalars, which are used in further computation.</p>
<p>The defined helper types are listed below:</p>
<pre>
%dx.types.ResRet.i8  = type { i8, i8, i8, i8, i32 }
%dx.types.ResRet.i16 = type { i16, i16, i16, i16, i32 }
%dx.types.ResRet.i32 = type { i32, i32, i32, i32, i32 }
%dx.types.ResRet.i64 = type { i64, i64, i64, i64, i32 }
%dx.types.ResRet.f16 = type { half, half, half, half, i32 }
%dx.types.ResRet.f32 = type { float, float, float, float, i32 }
%dx.types.ResRet.f64 = type { double, double, double, double, i32 }

%dx.types.Dimensions = type { i32, i32, i32, i32 }
%dx.types.SamplePos  = type { float, float }
</pre>
<a name="resource-handles"></a>
<h4>Resource handles</h4>
<p>Resources are identified via handles passed to resource operations. Handles are represented via opaque type:</p>
<pre>
%dx.types.Handle     = type { i8 * }
</pre>
<p>The handles are created out of resource range ID and index into the range:</p>
<pre>
declare %dx.types.Handle &#64;dx.op.createHandle(
    i32,                  ; opcode
    i8,                   ; resource class: SRV=0, UAV=1, CBV=2, Sampler=3
    i32,                  ; resource range ID (constant)
    i32,                  ; index into the range
    i1)                   ; non-uniform resource index: false or true
</pre>
<p>Resource class is a constant that indicates which metadata list (SRV, UAV, CBV, Sampler) to use for property queries.</p>
<p>Resource range ID is an i32 constant, which is the position of the metadata record in the corresponding metadata list. Range IDs start with 0 and are contiguous within each list.</p>
<p>Index is an i32 value that may be a constant or a value computed by the shader.</p>
<a name="cbufferloadlegacy"></a>
<h4>CBufferLoadLegacy</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
 ; overloads: SM5.1: f32|i32|f64,  future SM: possibly deprecated
%dx.types.CBufRet.f32 = type { float, float, float, float }
declare %dx.types.CBufRet.f32 &#64;dx.op.cbufferLoadLegacy.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32)                      ; 0-based row index (row = 16-byte DXBC register)
</pre>
<p>Valid resource types: ConstantBuffer. Valid shader model: SM5.1 and earlier.</p>
<p>The operation loads four 32-bit values from a constant buffer, which has legacy, 16-byte layout. Values are extracted via &quot;extractvalue&quot; instruction; unused values may be optimized away by the driver compiler. The operation respects SM5.1 and earlier OOB behavior for cbuffers.</p>
<a name="cbufferload"></a>
<h4>CBufferLoad</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32|f64,  SM6.0: f16|f32|f64|i16|i32|i64
declare float &#64;dx.op.cbufferLoad.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32,                      ; byte offset from the start of the buffer memory
    i32)                  ; read alignment
</pre>
<p>Valid resource types: ConstantBuffer.</p>
<p>The operation loads a value from a constant buffer, which has linear layout, using 1D index: byte offset from the beginning of the buffer memory. The operation respects SM5.1 and earlier OOB behavior for cbuffers.</p>
<p>Read alignment is a constant value identifying what the byte offset alignment is. If the actual byte offset does not have this alignment, the results of this operation are undefined.</p>
<a name="getdimensions"></a>
<h4>GetDimensions</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
declare %dx.types.Dimensions &#64;dx.op.getDimensions(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32)                  ; MIP level
</pre>
<p>This table describes the return component meanings for each resource type { c0, c1, c2, c3 }.</p>
<table class="docutils">
<colgroup>
<col width="36%" />
<col width="9%" />
<col width="18%" />
<col width="18%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource types</th>
<th class="head">c0</th>
<th class="head">c1</th>
<th class="head">c2</th>
<th class="head">c3</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>[RW]Texture1D</td>
<td>width</td>
<td>undef</td>
<td>undef</td>
<td>MIP levels</td>
</tr>
<tr><td>[RW]Texture1DArray</td>
<td>width</td>
<td>array size</td>
<td>undef</td>
<td>MIP levels</td>
</tr>
<tr><td>[RW]Texture2D</td>
<td>width</td>
<td>height</td>
<td>undef</td>
<td>MIP levels</td>
</tr>
<tr><td>[RW]Texture2DArray</td>
<td>width</td>
<td>height</td>
<td>array size</td>
<td>MIP levels</td>
</tr>
<tr><td>[RW]Texture3D</td>
<td>width</td>
<td>height</td>
<td>depth</td>
<td>MIP levels</td>
</tr>
<tr><td>[RW]Texture2DMS</td>
<td>width</td>
<td>height</td>
<td>undef</td>
<td>samples</td>
</tr>
<tr><td>[RW]Texture2DMSArray</td>
<td>width</td>
<td>height</td>
<td>array size</td>
<td>samples</td>
</tr>
<tr><td>TextureCUBE</td>
<td>width</td>
<td>height</td>
<td>undef</td>
<td>MIP levels</td>
</tr>
<tr><td>TextureCUBEArray</td>
<td>width</td>
<td>height</td>
<td>array size</td>
<td>MIP levels</td>
</tr>
<tr><td>[RW]TypedBuffer</td>
<td>width</td>
<td>undef</td>
<td>undef</td>
<td>undef</td>
</tr>
<tr><td>[RW]RawBuffer</td>
<td>width</td>
<td>undef</td>
<td>undef</td>
<td>undef</td>
</tr>
<tr><td>[RW]StructuredBuffer</td>
<td>width</td>
<td>undef</td>
<td>undef</td>
<td>undef</td>
</tr>
</tbody>
</table>
<p>MIP levels is always undef for RW resources.  Undef means the component will not be used.  The validator will verify this.
There is no GetDimensions that returns float values.</p>
<a name="sample"></a>
<h4>Sample</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32,  SM6.0: f16|f32
declare %dx.types.ResRet.f32 &#64;dx.op.sample.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0
    float,                ; coordinate c1
    float,                ; coordinate c2
    float,                ; coordinate c3
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32,                  ; offset o2
    float)                ; clamp
</pre>
<table class="docutils">
<colgroup>
<col width="27%" />
<col width="46%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
<th class="head"># of active offsets</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Texture1D</td>
<td>1 (c0)</td>
<td>1 (o0)</td>
</tr>
<tr><td>Texture1DArray</td>
<td>2 (c0, c1 = array slice)</td>
<td>1 (o0)</td>
</tr>
<tr><td>Texture2D</td>
<td>2 (c0, c1)</td>
<td>2 (o0, o1)</td>
</tr>
<tr><td>Texture2DArray</td>
<td>3 (c0, c1, c2 = array slice)</td>
<td>2 (o0, o1)</td>
</tr>
<tr><td>Texture3D</td>
<td>3 (c0, c1, c2)</td>
<td>3 (o0, o1, o2)</td>
</tr>
<tr><td>TextureCUBE</td>
<td>3 (c0, c1, c2)</td>
<td>0</td>
</tr>
<tr><td>TextureCUBEArray</td>
<td>4 (c0, c1, c2, c3 = array slice)</td>
<td>0</td>
</tr>
</tbody>
</table>
<a name="samplebias"></a>
<h4>SampleBias</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32,  SM6.0: f16|f32
declare %dx.types.ResRet.f32 &#64;dx.op.sampleBias.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0
    float,                ; coordinate c1
    float,                ; coordinate c2
    float,                ; coordinate c3
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32,                  ; offset o2
    float,                ; bias: in [-16.f,15.99f]
    float)                ; clamp
</pre>
<p>Valid resource types and active coordinates/offsets are the same as for the sample operation.</p>
<a name="samplelevel"></a>
<h4>SampleLevel</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32,  SM6.0: f16|f32
declare %dx.types.ResRet.f32 &#64;dx.op.sampleLevel.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0
    float,                ; coordinate c1
    float,                ; coordinate c2
    float,                ; coordinate c3
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32,                  ; offset o2
    float)                ; LOD
</pre>
<p>Valid resource types and active coordinates/offsets are the same as for the sample operation.</p>
<a name="samplegrad"></a>
<h4>SampleGrad</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32,  SM6.0: f16|f32
declare %dx.types.ResRet.f32 &#64;dx.op.sampleGrad.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0
    float,                ; coordinate c1
    float,                ; coordinate c2
    float,                ; coordinate c3
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32,                  ; offset o2
    float,                ; ddx0
    float,                ; ddx1
    float,                ; ddx2
    float,                ; ddy0
    float,                ; ddy1
    float,                ; ddy2
    float)                ; clamp
</pre>
<table class="docutils">
<colgroup>
<col width="18%" />
<col width="30%" />
<col width="18%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
<th class="head"># of active offsets</th>
<th class="head"># of active gradients</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Texture1D</td>
<td>1 (c0)</td>
<td>1 (o0)</td>
<td>1 (ddx0/ddy0)</td>
</tr>
<tr><td>Texture1DArray</td>
<td>2 (c0, c1 = array slice)</td>
<td>1 (o0)</td>
<td>1 (ddx0/ddy0)</td>
</tr>
<tr><td>Texture2D</td>
<td>2 (c0, c1)</td>
<td>2 (o0, o1)</td>
<td>2 (ddx0/ddy0, ddx1/ddy1)</td>
</tr>
<tr><td>Texture2DArray</td>
<td>3 (c0, c1, c2 = array slice)</td>
<td>2 (o0, o1)</td>
<td>2 (ddx0/ddy0, ddx1/ddy1)</td>
</tr>
<tr><td>Texture3D</td>
<td>3 (c0, c1, c2)</td>
<td>3 (o0, o1, o2)</td>
<td>3 (ddx0/ddy0, ddx1/ddy1, ddx2,ddy2)</td>
</tr>
<tr><td>TextureCUBE</td>
<td>3 (c0, c1, c2)</td>
<td>0</td>
<td>3 (ddx0/ddy0, ddx1/ddy1, ddx2,ddy2)</td>
</tr>
<tr><td>TextureCUBEArray</td>
<td>4 (c0, c1, c2, c3 = array slice)</td>
<td>0</td>
<td>3 (ddx0/ddy0, ddx1/ddy1, ddx2,ddy2)</td>
</tr>
</tbody>
</table>
<a name="samplecmp"></a>
<h4>SampleCmp</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32,  SM6.0: f16|f32
declare %dx.types.ResRet.f32 &#64;dx.op.sampleCmp.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0
    float,                ; coordinate c1
    float,                ; coordinate c2
    float,                ; coordinate c3
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32,                  ; offset o2
    float,                ; compare value
    float)                ; clamp
</pre>
<table class="docutils">
<colgroup>
<col width="27%" />
<col width="46%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
<th class="head"># of active offsets</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Texture1D</td>
<td>1 (c0)</td>
<td>1 (o0)</td>
</tr>
<tr><td>Texture1DArray</td>
<td>2 (c0, c1 = array slice)</td>
<td>1 (o0)</td>
</tr>
<tr><td>Texture2D</td>
<td>2 (c0, c1)</td>
<td>2 (o0, o1)</td>
</tr>
<tr><td>Texture2DArray</td>
<td>3 (c0, c1, c2 = array slice)</td>
<td>2 (o0, o1)</td>
</tr>
<tr><td>TextureCUBE</td>
<td>3 (c0, c1, c2)</td>
<td>0</td>
</tr>
<tr><td>TextureCUBEArray</td>
<td>4 (c0, c1, c2, c3 = array slice)</td>
<td>0</td>
</tr>
</tbody>
</table>
<a name="samplecmplevelzero"></a>
<h4>SampleCmpLevelZero</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32,  SM6.0: f16|f32
declare %dx.types.ResRet.f32 &#64;dx.op.sampleCmpLevelZero.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0
    float,                ; coordinate c1
    float,                ; coordinate c2
    float,                ; coordinate c3
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32,                  ; offset o2
    float)                ; compare value
</pre>
<p>Valid resource types and active coordinates/offsets are the same as for the sampleCmp operation.</p>
<a name="textureload"></a>
<h4>TextureLoad</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32,  SM6.0: f16|f32|i16|i32
declare %dx.types.ResRet.f32 &#64;dx.op.textureLoad.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    i32,                  ; MIP level; sample for Texture2DMS
    i32,                  ; coordinate c0
    i32,                  ; coordinate c1
    i32,                  ; coordinate c2
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32)                  ; offset o2
</pre>
<table class="docutils">
<colgroup>
<col width="25%" />
<col width="12%" />
<col width="37%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head">MIP level</th>
<th class="head"># of active coordinates</th>
<th class="head"># of active offsets</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Texture1D</td>
<td>yes</td>
<td>1 (c0)</td>
<td>1 (o0)</td>
</tr>
<tr><td>RWTexture1D</td>
<td>undef</td>
<td>1 (c0)</td>
<td>undef</td>
</tr>
<tr><td>Texture1DArray</td>
<td>yes</td>
<td>2 (c0, c1 = array slice)</td>
<td>1 (o0)</td>
</tr>
<tr><td>RWTexture1DArray</td>
<td>undef</td>
<td>2 (c0, c1 = array slice)</td>
<td>undef</td>
</tr>
<tr><td>Texture2D</td>
<td>yes</td>
<td>2 (c0, c1)</td>
<td>2 (o0, o1)</td>
</tr>
<tr><td>RWTexture2D</td>
<td>undef</td>
<td>2 (c0, c1)</td>
<td>undef</td>
</tr>
<tr><td>Texture2DArray</td>
<td>yes</td>
<td>3 (c0, c1, c2 = array slice)</td>
<td>2 (o0, o1)</td>
</tr>
<tr><td>RWTexture2DArray</td>
<td>undef</td>
<td>3 (c0, c1, c2 = array slice)</td>
<td>undef</td>
</tr>
<tr><td>Texture3D</td>
<td>yes</td>
<td>3 (c0, c1, c2)</td>
<td>3 (o0, o1, o2)</td>
</tr>
<tr><td>RWTexture3D</td>
<td>undef</td>
<td>3 (c0, c1, c2)</td>
<td>undef</td>
</tr>
</tbody>
</table>
<p>For Texture2DMS:</p>
<table class="docutils">
<colgroup>
<col width="30%" />
<col width="19%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head">Sample index</th>
<th class="head"># of active coordinate components</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Texture2DMS</td>
<td>yes</td>
<td>2 (c0, c1)</td>
</tr>
<tr><td>Texture2DMSArray</td>
<td>yes</td>
<td>3 (c0, c1, c2 = array slice)</td>
</tr>
</tbody>
</table>
<a name="texturestore"></a>
<h4>TextureStore</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32,  SM6.0: f16|f32|i16|i32
; returns: status
declare void &#64;dx.op.textureStore.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    i32,                  ; coordinate c0
    i32,                  ; coordinate c1
    i32,                  ; coordinate c2
    float,                ; value v0
    float,                ; value v1
    float,                ; value v2
    float,                ; value v3
    i8)                   ; write mask
</pre>
<p>The write mask indicates which components are written (x - 1, y - 2, z - 4, w - 8), similar to DXBC. The mask must cover all resource components.</p>
<table class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinate components</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>RWTexture1D</td>
<td>1 (c0)</td>
</tr>
<tr><td>RWTexture1DArray</td>
<td>2 (c0, c1 = array slice)</td>
</tr>
<tr><td>RWTexture2D</td>
<td>2 (c0, c1)</td>
</tr>
<tr><td>RWTexture2DArray</td>
<td>3 (c0, c1, c2 = array slice)</td>
</tr>
<tr><td>RWTexture3D</td>
<td>3 (c0, c1, c2)</td>
</tr>
</tbody>
</table>
<a name="calculatelod"></a>
<h4>CalculateLOD</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; returns: LOD
declare float &#64;dx.op.calculateLOD.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0, [0.0, 1.0]
    float,                ; coordinate c1, [0.0, 1.0]
    float,                ; coordinate c2, [0.0, 1.0]
    i1)                   ; true - clamped; false - unclamped
</pre>
<table class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Texture1D, Texture1DArray</td>
<td>1 (c0)</td>
</tr>
<tr><td>Texture2D, Texture2DArray</td>
<td>2 (c0, c1)</td>
</tr>
<tr><td>Texture3D</td>
<td>3 (c0, c1, c2)</td>
</tr>
<tr><td>TextureCUBE, TextureCUBEArray</td>
<td>3 (c0, c1, c2)</td>
</tr>
</tbody>
</table>
<a name="texturegather"></a>
<h4>TextureGather</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32,  SM6.0: f16|f32|i16|i32
declare %dx.types.ResRet.f32 &#64;dx.op.textureGather.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0
    float,                ; coordinate c1
    float,                ; coordinate c2
    float,                ; coordinate c3
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32)                  ; channel, constant in {0=red,1=green,2=blue,3=alpha}
</pre>
<table class="docutils">
<colgroup>
<col width="27%" />
<col width="46%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
<th class="head"># of active offsets</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Texture2D</td>
<td>2 (c0, c1)</td>
<td>2 (o0, o1)</td>
</tr>
<tr><td>Texture2DArray</td>
<td>3 (c0, c1, c2 = array slice)</td>
<td>2 (o0, o1)</td>
</tr>
<tr><td>TextureCUBE</td>
<td>3 (c0, c1, c2)</td>
<td>0</td>
</tr>
<tr><td>TextureCUBEArray</td>
<td>4 (c0, c1, c2, c3 = array slice)</td>
<td>0</td>
</tr>
</tbody>
</table>
<a name="texturegathercmp"></a>
<h4>TextureGatherCmp</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32,  SM6.0: f16|f32|i16|i32
declare %dx.types.ResRet.f32 &#64;dx.op.textureGatherCmp.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    %dx.types.Handle,     ; sampler handle
    float,                ; coordinate c0
    float,                ; coordinate c1
    float,                ; coordinate c2
    float,                ; coordinate c3
    i32,                  ; offset o0
    i32,                  ; offset o1
    i32,                  ; channel, constant in {0=red,1=green,2=blue,3=alpha}
    float)                ; compare value
</pre>
<p>Valid resource types and active coordinates/offsets are the same as for the textureGather operation.</p>
<a name="texture2dmsgetsampleposition"></a>
<h4>Texture2DMSGetSamplePosition</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
declare %dx.types.SamplePos &#64;dx.op.texture2DMSGetSamplePosition(
    i32,                  ; opcode
    %dx.types.Handle,     ; texture handle
    i32)                  ; sample ID
</pre>
<p>Returns sample position of a texture.</p>
<a name="rendertargetgetsampleposition"></a>
<h4>RenderTargetGetSamplePosition</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
declare %dx.types.SamplePos &#64;dx.op.renderTargetGetSamplePosition(
    i32,                  ; opcode
    i32)                  ; sample ID
</pre>
<p>Returns sample position of a render target.</p>
<a name="rendertargetgetsamplecount"></a>
<h4>RenderTargetGetSampleCount</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
declare i32 &#64;dx.op.renderTargetGetSampleCount(
    i32)                  ; opcode
</pre>
<p>Returns sample count of a render target.</p>
<a name="bufferload"></a>
<h4>BufferLoad</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32,  SM6.0: f32|i32
; returns: status
declare %dx.types.ResRet.f32 &#64;dx.op.bufferLoad.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32,                  ; coordinate c0
    i32)                  ; coordinate c1
</pre>
<p>The call respects SM5.1 OOB and alignment rules.</p>
<table class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>[RW]TypedBuffer</td>
<td>1 (c0 in elements)</td>
</tr>
<tr><td>[RW]RawBuffer</td>
<td>1 (c0 in bytes)</td>
</tr>
<tr><td>[RW]StructuredBuffer</td>
<td>2 (c0 in elements, c1 = byte offset into the element)</td>
</tr>
</tbody>
</table>
<a name="rawbufferload"></a>
<h4>RawBufferLoad</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32,  SM6.0: f32|i32, SM6.2: f16|f32|i16|i32
; returns: status
declare %dx.types.ResRet.f32 &#64;dx.op.rawBufferLoad.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32,                  ; coordinate c0 (index)
    i32,                  ; coordinate c1 (elementOffset)
    i8,                   ; mask
    i32,                  ; alignment
)
</pre>
<p>The call respects SM5.1 OOB and alignment rules.</p>
<table class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>[RW]RawBuffer</td>
<td>1 (c0 in bytes)</td>
</tr>
<tr><td>[RW]StructuredBuffer</td>
<td>2 (c0 in elements, c1 = byte offset into the element)</td>
</tr>
</tbody>
</table>
<a name="bufferstore"></a>
<h4>BufferStore</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32,  SM6.0: f32|i32
declare void &#64;dx.op.bufferStore.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32,                  ; coordinate c0
    i32,                  ; coordinate c1
    float,                ; value v0
    float,                ; value v1
    float,                ; value v2
    float,                ; value v3
    i8)                   ; write mask
</pre>
<p>The call respects SM5.1 OOB and alignment rules.</p>
<p>The write mask indicates which components are written (x - 1, y - 2, z - 4, w - 8), similar to DXBC. For RWTypedBuffer, the mask must cover all resource components. For RWRawBuffer and RWStructuredBuffer, valid masks are: x, xy, xyz, xyzw.</p>
<table class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>RWTypedBuffer</td>
<td>1 (c0 in elements)</td>
</tr>
<tr><td>RWRawBuffer</td>
<td>1 (c0 in bytes)</td>
</tr>
<tr><td>RWStructuredBuffer</td>
<td>2 (c0 in elements, c1 = byte offset into the element)</td>
</tr>
</tbody>
</table>
<a name="rawbufferstore"></a>
<h4>RawBufferStore</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: f32|i32,  SM6.0: f32|i32, SM6.2: f16|f32|i16|i32
declare void &#64;dx.op.rawBufferStore.f32(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32,                  ; coordinate c0 (index)
    i32,                  ; coordinate c1 (elementOffset)
    float,                ; value v0
    float,                ; value v1
    float,                ; value v2
    float,                ; value v3
    i8,                   ; write mask
    i32)                  ; alignment
</pre>
<p>The call respects SM5.1 OOB and alignment rules.</p>
<p>The write mask indicates which components are written (x - 1, y - 2, z - 4, w - 8), similar to DXBC. For RWTypedBuffer, the mask must cover all resource components. For RWRawBuffer and RWStructuredBuffer, valid masks are: x, xy, xyz, xyzw.</p>
<table class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>RWRawbuffer</td>
<td>1 (c0 in bytes)</td>
</tr>
<tr><td>RWStructuredbuffer</td>
<td>2 (c0 in elements, c1 = byte offset into the element)</td>
</tr>
</tbody>
</table>
<a name="bufferupdatecounter"></a>
<h4>BufferUpdateCounter</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; opcodes: bufferUpdateCounter
declare void &#64;dx.op.bufferUpdateCounter(
    i32,                  ; opcode
    %dx.types.ResHandle,  ; buffer handle
    i8)                   ; 1 - increment, -1 - decrement
</pre>
<p>Valid resource type: RWRawBuffer.</p>
<a name="atomicbinop"></a>
<h4>AtomicBinOp</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: i32,  SM6.0: i32
; returns: original value in memory before the operation
declare i32 &#64;dx.op.atomicBinOp.i32(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32,                  ; binary operation code: EXCHANGE, IADD, AND, OR, XOR, IMIN, IMAX, UMIN, UMAX
    i32,                  ; coordinate c0
    i32,                  ; coordinate c1
    i32,                  ; coordinate c2
    i32)                  ; new value
</pre>
<p>The call respects SM5.1 OOB and alignment rules.</p>
<table class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>RWTexture1D</td>
<td>1 (c0)</td>
</tr>
<tr><td>RWTexture1DArray</td>
<td>2 (c0, c1 = array slice)</td>
</tr>
<tr><td>RWTexture2D</td>
<td>2 (c0, c1)</td>
</tr>
<tr><td>RWTexture2DArray</td>
<td>3 (c0, c1, c2 = array slice)</td>
</tr>
<tr><td>RWTexture3D</td>
<td>3 (c0, c1, c2)</td>
</tr>
<tr><td>RWTypedBuffer</td>
<td>1 (c0 in elements)</td>
</tr>
<tr><td>RWRawBuffer</td>
<td>1 (c0 in bytes)</td>
</tr>
<tr><td>RWStructuredBuffer</td>
<td>2 (c0 in elements, c1 - byte offset into the element)</td>
</tr>
</tbody>
</table>
<p>AtomicBinOp subsumes corresponding DXBC atomic operations that do not return the old value in memory. The driver compiler is free to specialize the corresponding GPU instruction if the return value is unused.</p>
<a name="atomiccompareexchange"></a>
<h4>AtomicCompareExchange</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
; overloads: SM5.1: i32,  SM6.0: i32
; returns: original value in memory before the operation
declare i32 &#64;dx.op.atomicCompareExchange.i32(
    i32,                  ; opcode
    %dx.types.Handle,     ; resource handle
    i32,                  ; coordinate c0
    i32,                  ; coordinate c1
    i32,                  ; coordinate c2
    i32,                  ; comparison value
    i32)                  ; new value
</pre>
<p>The call respects SM5.1 OOB and alignment rules.</p>
<table class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Valid resource type</th>
<th class="head"># of active coordinates</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>RWTexture1D</td>
<td>1 (c0)</td>
</tr>
<tr><td>RWTexture1DArray</td>
<td>2 (c0, c1 = array slice)</td>
</tr>
<tr><td>RWTexture2D</td>
<td>2 (c0, c1)</td>
</tr>
<tr><td>RWTexture2DArray</td>
<td>3 (c0, c1, c2 = array slice)</td>
</tr>
<tr><td>RWTexture3D</td>
<td>3 (c0, c1, c2)</td>
</tr>
<tr><td>RWTypedBuffer</td>
<td>1 (c0 in elements)</td>
</tr>
<tr><td>RWRawBuffer</td>
<td>1 (c0 in bytes)</td>
</tr>
<tr><td>RWStructuredBuffer</td>
<td>2 (c0 in elements, c1 - byte offset into the element)</td>
</tr>
</tbody>
</table>
<p>AtomicCompareExchange subsumes DXBC's atomic compare store. The driver compiler is free to specialize the corresponding GPU instruction if the return value is unused.</p>
<a name="getbufferbaseptr-sm6-0"></a>
<h4>GetBufferBasePtr (SM6.0)</h4>
<p>The following signature shows the operation syntax:</p>
<pre>
Returns i8* pointer to the base of [RW]RawBuffer instance.
declare i8 addrspace(ASmemory) * &#64;dx.op.getBufferBasePtr.pASmemory (
    i32,                ; opcode
    %dx.types.Handle)   ; resource handle
Returns i8* pointer to the base of ConstantBuffer instance.
declare i8 addrspace(AScbuffer) * &#64;dx.op.getBufferBasePtr.pAScbuffer(
    i32,                ; opcode
    %dx.types.Handle)   ; resource handle
</pre>
<p>Given SM5.1 resource handle, return base pointer to perform pointer-based accesses to the resource memory.</p>
<p>Note: the functionality is requested for SM6.0 to support pointer-based accesses to SM5.1 resources with raw linear memory (raw buffer and cbuffer) in HLSL next. This would be one of the way how a valid pointer is produced in the shader, and would let new-style, pointer-based code access SM5.1 resources with linear memory view.</p>
<a name="atomic-operations-via-pointer"></a>
<h4>Atomic operations via pointer</h4>
<p>Groupshared memory atomic operations are done via LLVM atomic instructions atomicrmw and cmpxchg. The instructions accept only i32 addrspace(ASgs) * pointers, where ASgs is the addrspace number of groupshared variables. Atomicrmw instruction does not support 'sub' and 'nand' operations. These constraints may be revisited in the future. OOB behavior is undefined.
SM6.0 will enable similar mechanism for atomic operations performed on device memory (raw buffer).</p>
<a name="samplers"></a>
<h3><a class="toc-backref" href="#toc-entry-49">Samplers</a></h3>
<p>There are no intrinsics for samplers. Sampler reflection data is represented similar to other resources.</p>
<a name="immediate-constant-buffer"></a>
<h3><a class="toc-backref" href="#toc-entry-50">Immediate Constant Buffer</a></h3>
<p>There is no immediate constant buffer in DXIL. Instead, indexable constants are represented via LLVM global initialized constants in address space ASicb.</p>
<a name="texture-buffers"></a>
<h3><a class="toc-backref" href="#toc-entry-51">Texture Buffers</a></h3>
<p>A texture buffer is mapped to RawBuffer. Texture buffer variable declarations are present for reflection purposes only.</p>
<a name="groupshared-memory"></a>
<h3><a class="toc-backref" href="#toc-entry-52">Groupshared memory</a></h3>
<p>Groupshared memory (DXBC g-registers) is linear in DXIL. Groupshared variables are declared via global variables in addrspace(ASgs). The optimizer will not group variables; the driver compiler can do this if desired. Accesses to groupshared variables occur via pointer load/store instructions (see below).</p>
<a name="indexable-threadlocal-memory"></a>
<h3><a class="toc-backref" href="#toc-entry-53">Indexable threadlocal memory</a></h3>
<p>Indexable threadlocal memory (DXBC x-registers) is linear in DXIL. Threadlocal variables are &quot;declared&quot; via alloca instructions. Threadlocal variables are assumed to reside in addrspace(0). The variables are not allocated into some memory pool; the driver compiler can do this, if desired. Accesses to threadlocal variables occur via pointer load/store instructions (see below).</p>
<a name="load-store-atomics-via-pointer-in-future-sm"></a>
<h3><a class="toc-backref" href="#toc-entry-54">Load/Store/Atomics via pointer in future SM</a></h3>
<p>HLSL offers several abstractions with linear memory: buffers, cbuffers, groupshared and indexable threadlocal memory, that are conceptually similar, but have different HLSL syntax and some differences in behavior, which are exposed to HLSL developers. The plan is to introduce pointers into HLSL to unify access syntax to such linear-memory resources such that they appear conceptually the same to HLSL programmers.</p>
<p>Each resource memory type is expressed by a unique LLVM address space. The following table shows memory types and their address spaces:</p>
<table class="docutils">
<colgroup>
<col width="53%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Memory type</th>
<th class="head">Address space number n - addrspace(n)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>code, local, indexable threadlocal memory</td>
<td>AS_default = 0</td>
</tr>
<tr><td>device memory ([RW]RawBuffer)</td>
<td>AS_memory = 1</td>
</tr>
<tr><td>cbuffer-like memory (ConstantBuffer)</td>
<td>AS_cbuffer = 2</td>
</tr>
<tr><td>groupshared memory</td>
<td>AS_groupshared = 3</td>
</tr>
</tbody>
</table>
<p>Pointers can be produced in the shader in a variety of ways (see Memory accesses section). Note that if GetBaseBufferPtr was used on [RW]RawBuffer or ConstantBuffer to produce a pointer, the base pointer is stateless; i.e., it &quot;loses its connection&quot; to the underlying resource and is treated as a stateless pointer into a particular memory type.</p>
<a name="additional-resource-properties"></a>
<h3><a class="toc-backref" href="#toc-entry-55">Additional resource properties</a></h3>
<p>TODO: enumerate all additional resource range properties, e.g., ROV, Texture2DMS, globally coherent, UAV counter, sampler mode, CB: immediate/dynamic indexed.</p>
<a name="operations"></a>
<h2><a class="toc-backref" href="#toc-entry-56">Operations</a></h2>
<p>DXIL operations are represented in two ways: using LLVM instructions and using LLVM external functions.</p>
<a name="operations-via-instructions"></a>
<h3><a class="toc-backref" href="#toc-entry-57">Operations via instructions</a></h3>
<p>DXIL uses a subset of core LLVM IR instructions that make sense for HLSL, where the meaning of the LLVM IR operation matches the meaning of the HLSL operation.</p>
<p>The following LLVM instructions are valid in a DXIL program, with the specified operand types where applicable. The legend for overload types (v)oid, (h)alf, (f)loat, (d)ouble, (1)-bit, (8)-bit, (w)ord, (i)nt, (l)ong.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="70%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Instruction</th>
<th class="head">Action</th>
<th class="head">Operand overloads</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Ret</td>
<td>returns a value (possibly void), from a function.</td>
<td>vhfd1wil</td>
</tr>
<tr><td>Br</td>
<td>branches (conditional or unconditional)</td>
<td>&nbsp;</td>
</tr>
<tr><td>Switch</td>
<td>performs a multiway switch</td>
<td>&nbsp;</td>
</tr>
<tr><td>Add</td>
<td>returns the sum of its two operands</td>
<td>wil</td>
</tr>
<tr><td>FAdd</td>
<td>returns the sum of its two operands</td>
<td>hfd</td>
</tr>
<tr><td>Sub</td>
<td>returns the difference of its two operands</td>
<td>wil</td>
</tr>
<tr><td>FSub</td>
<td>returns the difference of its two operands</td>
<td>hfd</td>
</tr>
<tr><td>Mul</td>
<td>returns the product of its two operands</td>
<td>wil</td>
</tr>
<tr><td>FMul</td>
<td>returns the product of its two operands</td>
<td>hfd</td>
</tr>
<tr><td>UDiv</td>
<td>returns the quotient of its two unsigned operands</td>
<td>wil</td>
</tr>
<tr><td>SDiv</td>
<td>returns the quotient of its two signed operands</td>
<td>wil</td>
</tr>
<tr><td>FDiv</td>
<td>returns the quotient of its two operands</td>
<td>hfd</td>
</tr>
<tr><td>URem</td>
<td>returns the remainder from the unsigned division of its two operands</td>
<td>wil</td>
</tr>
<tr><td>SRem</td>
<td>returns the remainder from the signed division of its two operands</td>
<td>wil</td>
</tr>
<tr><td>FRem</td>
<td>returns the remainder from the division of its two operands</td>
<td>hfd</td>
</tr>
<tr><td>Shl</td>
<td>shifts left (logical)</td>
<td>wil</td>
</tr>
<tr><td>LShr</td>
<td>shifts right (logical), with zero bit fill</td>
<td>wil</td>
</tr>
<tr><td>AShr</td>
<td>shifts right (arithmetic), with 'a' operand sign bit fill</td>
<td>wil</td>
</tr>
<tr><td>And</td>
<td>returns a  bitwise logical and of its two operands</td>
<td>1wil</td>
</tr>
<tr><td>Or</td>
<td>returns a bitwise logical or of its two operands</td>
<td>1wil</td>
</tr>
<tr><td>Xor</td>
<td>returns a bitwise logical xor of its two operands</td>
<td>1wil</td>
</tr>
<tr><td>Alloca</td>
<td>allocates memory on the stack frame of the currently executing function</td>
<td>&nbsp;</td>
</tr>
<tr><td>Load</td>
<td>reads from memory</td>
<td>&nbsp;</td>
</tr>
<tr><td>Store</td>
<td>writes to memory</td>
<td>&nbsp;</td>
</tr>
<tr><td>GetElementPtr</td>
<td>gets the address of a subelement of an aggregate value</td>
<td>&nbsp;</td>
</tr>
<tr><td>AtomicCmpXchg</td>
<td>atomically modifies memory</td>
<td>&nbsp;</td>
</tr>
<tr><td>AtomicRMW</td>
<td>atomically modifies memory</td>
<td>&nbsp;</td>
</tr>
<tr><td>Trunc</td>
<td>truncates an integer</td>
<td>1wil</td>
</tr>
<tr><td>ZExt</td>
<td>zero extends an integer</td>
<td>1wil</td>
</tr>
<tr><td>SExt</td>
<td>sign extends an integer</td>
<td>1wil</td>
</tr>
<tr><td>FPToUI</td>
<td>converts a floating point to UInt</td>
<td>hfd1wil</td>
</tr>
<tr><td>FPToSI</td>
<td>converts a floating point to SInt</td>
<td>hfd1wil</td>
</tr>
<tr><td>UIToFP</td>
<td>converts a UInt to floating point</td>
<td>hfd1wil</td>
</tr>
<tr><td>SIToFP</td>
<td>converts a SInt to floating point</td>
<td>hfd1wil</td>
</tr>
<tr><td>FPTrunc</td>
<td>truncates a floating point</td>
<td>hfd</td>
</tr>
<tr><td>FPExt</td>
<td>extends a floating point</td>
<td>hfd</td>
</tr>
<tr><td>BitCast</td>
<td>performs a bit-preserving type cast</td>
<td>hfd1wil</td>
</tr>
<tr><td>AddrSpaceCast</td>
<td>casts a value addrspace</td>
<td>&nbsp;</td>
</tr>
<tr><td>ICmp</td>
<td>compares integers</td>
<td>1wil</td>
</tr>
<tr><td>FCmp</td>
<td>compares floating points</td>
<td>hfd</td>
</tr>
<tr><td>PHI</td>
<td>is a PHI node instruction</td>
<td>&nbsp;</td>
</tr>
<tr><td>Call</td>
<td>calls a function</td>
<td>&nbsp;</td>
</tr>
<tr><td>Select</td>
<td>selects an instruction</td>
<td>&nbsp;</td>
</tr>
<tr><td>ExtractValue</td>
<td>extracts from aggregate</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="fadd"></a>
<h4>FAdd</h4>
<p>%des = fadd float %src0, %src1</p>
<p>The following table shows the results obtained when executing the instruction with various classes of numbers, assuming that &quot;fp32-denorm-mode&quot;=&quot;preserve&quot;.
For &quot;fp32-denorm-mode&quot;=&quot;ftz&quot; mode, denorms inputs should be treated as corresponding signed zero, and any resulting denorm is also flushed to zero.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="11%" />
<col width="13%" />
<col width="5%" />
<col width="5%" />
<col width="14%" />
<col width="11%" />
<col width="8%" />
<col width="7%" />
</colgroup>
<tbody valign="top">
<tr><td>src0src1</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr><td>-F</td>
<td>-inf</td>
<td>-F</td>
<td>-F</td>
<td>src0</td>
<td>src0</td>
<td>-F</td>
<td>+/-F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>-denorm</td>
<td>-inf</td>
<td>-F</td>
<td>-F/denorm</td>
<td>src0</td>
<td>src0</td>
<td>+/-denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>-0</td>
<td>-inf</td>
<td>src1</td>
<td>src1</td>
<td>-0</td>
<td>+0</td>
<td>src1</td>
<td>src1</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>+0</td>
<td>-inf</td>
<td>src1</td>
<td>src1</td>
<td>-0</td>
<td>+0</td>
<td>src1</td>
<td>src1</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>+denorm</td>
<td>-inf</td>
<td>-F</td>
<td>+/-denorm</td>
<td>src0</td>
<td>src0</td>
<td>+F/denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>+F</td>
<td>-inf</td>
<td>+/-F</td>
<td>+F</td>
<td>src0</td>
<td>src0</td>
<td>+F</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>+inf</td>
<td>NaN</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="fdiv"></a>
<h4>FDiv</h4>
<p>%dest = fdiv float %src0, %src1</p>
<p>The following table shows the results obtained when executing the instruction with various classes of numbers, assuming that fast math flag is not used and &quot;fp32-denorm-mode&quot;=&quot;preserve&quot;.
When &quot;fp32-denorm-mode&quot;=&quot;ftz&quot;, denorm inputs should be interpreted as corresponding signed zero, and any resulting denorm is also flushed to zero.
When fast math is enabled, implementation may use reciprocal form: src0*(1/src1).  This may result in evaluating src0*(+/-)INF from src0*(1/(+/-)denorm).  This may produce NaN in some cases or (+/-)INF in others.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="11%" />
<col width="9%" />
<col width="8%" />
<col width="10%" />
<col width="5%" />
<col width="5%" />
<col width="10%" />
<col width="8%" />
<col width="9%" />
<col width="7%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src0\src1</td>
<td>-inf</td>
<td>-F</td>
<td>-1</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+1</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>-inf</td>
<td>NaN</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr><td>-F</td>
<td>+0</td>
<td>+F</td>
<td>-src0</td>
<td>+F</td>
<td>+inf</td>
<td>-inf</td>
<td>-F</td>
<td>src0</td>
<td>-F</td>
<td>-0</td>
<td>NaN</td>
</tr>
<tr><td>-denorm</td>
<td>+0</td>
<td>+denorm</td>
<td>-src0</td>
<td>+F</td>
<td>+inf</td>
<td>-inf</td>
<td>-F</td>
<td>src0</td>
<td>-denorm</td>
<td>-0</td>
<td>NaN</td>
</tr>
<tr><td>-0</td>
<td>+0</td>
<td>+0</td>
<td>+0</td>
<td>0</td>
<td>NaN</td>
<td>NaN</td>
<td>0</td>
<td>-0</td>
<td>-0</td>
<td>-0</td>
<td>NaN</td>
</tr>
<tr><td>+0</td>
<td>-0</td>
<td>-0</td>
<td>-0</td>
<td>0</td>
<td>NaN</td>
<td>NaN</td>
<td>0</td>
<td>+0</td>
<td>+0</td>
<td>+0</td>
<td>NaN</td>
</tr>
<tr><td>+denorm</td>
<td>-0</td>
<td>-denorm</td>
<td>-src0</td>
<td>-F</td>
<td>-inf</td>
<td>+inf</td>
<td>+F</td>
<td>src0</td>
<td>+denorm</td>
<td>+0</td>
<td>NaN</td>
</tr>
<tr><td>+F</td>
<td>-0</td>
<td>-F</td>
<td>-src0</td>
<td>-F</td>
<td>-inf</td>
<td>+inf</td>
<td>+F</td>
<td>src0</td>
<td>+F</td>
<td>+0</td>
<td>NaN</td>
</tr>
<tr><td>+inf</td>
<td>NaN</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr><td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="operations-via-external-functions"></a>
<h3><a class="toc-backref" href="#toc-entry-58">Operations via external functions</a></h3>
<p>Operations missing in core LLVM IR, such as abs, fma, discard, etc., are represented by external functions, whose name is prefixed with dx.op.</p>
<p>The very first parameter of each such external function is the opcode of the operation, which is an i32 constant. For example, dx.op.unary computes a unary function T res = opcode(T input). Opcode defines which unary function to perform.</p>
<p>Opcodes are defined on a dense range and will be provided as enum in a header file. The opcode parameter is introduced for efficiency reasons: grouping of operations to reduce the total number of overloads and more efficient property lookup, e.g., via an array of operation properties rather than a hash table.</p>
<table class="docutils">
<colgroup>
<col width="1%" />
<col width="20%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">ID</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td><a class="reference internal" href="#tempregload">TempRegLoad</a></td>
<td>Helper load operation</td>
</tr>
<tr><td>1</td>
<td><a class="reference internal" href="#tempregstore">TempRegStore</a></td>
<td>Helper store operation</td>
</tr>
<tr><td>2</td>
<td><a class="reference internal" href="#minprecxregload">MinPrecXRegLoad</a></td>
<td>Helper load operation for minprecision</td>
</tr>
<tr><td>3</td>
<td><a class="reference internal" href="#minprecxregstore">MinPrecXRegStore</a></td>
<td>Helper store operation for minprecision</td>
</tr>
<tr><td>4</td>
<td><a class="reference internal" href="#loadinput">LoadInput</a></td>
<td>Loads the value from shader input</td>
</tr>
<tr><td>5</td>
<td><a class="reference internal" href="#storeoutput">StoreOutput</a></td>
<td>Stores the value to shader output</td>
</tr>
<tr><td>6</td>
<td><a class="reference internal" href="#fabs">FAbs</a></td>
<td>returns the absolute value of the input value.</td>
</tr>
<tr><td>7</td>
<td><a class="reference internal" href="#saturate">Saturate</a></td>
<td>clamps the result of a single or double precision floating point value to [0.0f...1.0f]</td>
</tr>
<tr><td>8</td>
<td><a class="reference internal" href="#isnan">IsNaN</a></td>
<td>Returns true if x is NAN or QNAN, false otherwise.</td>
</tr>
<tr><td>9</td>
<td><a class="reference internal" href="#isinf">IsInf</a></td>
<td>Returns true if x is +INF or -INF, false otherwise.</td>
</tr>
<tr><td>10</td>
<td><a class="reference internal" href="#isfinite">IsFinite</a></td>
<td>Returns true if x is finite, false otherwise.</td>
</tr>
<tr><td>11</td>
<td><a class="reference internal" href="#isnormal">IsNormal</a></td>
<td>returns IsNormal</td>
</tr>
<tr><td>12</td>
<td><a class="reference internal" href="#cos">Cos</a></td>
<td>returns cosine(theta) for theta in radians.</td>
</tr>
<tr><td>13</td>
<td><a class="reference internal" href="#sin">Sin</a></td>
<td>returns sine(theta) for theta in radians.</td>
</tr>
<tr><td>14</td>
<td><a class="reference internal" href="#tan">Tan</a></td>
<td>returns tan(theta) for theta in radians.</td>
</tr>
<tr><td>15</td>
<td><a class="reference internal" href="#acos">Acos</a></td>
<td>Returns the arccosine of the specified value. Input should be a floating-point value within the range of -1 to 1.</td>
</tr>
<tr><td>16</td>
<td><a class="reference internal" href="#asin">Asin</a></td>
<td>Returns the arccosine of the specified value. Input should be a floating-point value within the range of -1 to 1</td>
</tr>
<tr><td>17</td>
<td><a class="reference internal" href="#atan">Atan</a></td>
<td>Returns the arctangent of the specified value. The return value is within the range of -PI/2 to PI/2.</td>
</tr>
<tr><td>18</td>
<td><a class="reference internal" href="#hcos">Hcos</a></td>
<td>returns the hyperbolic cosine of the specified value.</td>
</tr>
<tr><td>19</td>
<td><a class="reference internal" href="#hsin">Hsin</a></td>
<td>returns the hyperbolic sine of the specified value.</td>
</tr>
<tr><td>20</td>
<td><a class="reference internal" href="#htan">Htan</a></td>
<td>returns the hyperbolic tangent of the specified value.</td>
</tr>
<tr><td>21</td>
<td><a class="reference internal" href="#exp">Exp</a></td>
<td>returns 2^exponent</td>
</tr>
<tr><td>22</td>
<td><a class="reference internal" href="#frc">Frc</a></td>
<td>extract fracitonal component.</td>
</tr>
<tr><td>23</td>
<td><a class="reference internal" href="#log">Log</a></td>
<td>returns log base 2.</td>
</tr>
<tr><td>24</td>
<td><a class="reference internal" href="#sqrt">Sqrt</a></td>
<td>returns square root</td>
</tr>
<tr><td>25</td>
<td><a class="reference internal" href="#rsqrt">Rsqrt</a></td>
<td>returns reciprocal square root (1 / sqrt(src)</td>
</tr>
<tr><td>26</td>
<td><a class="reference internal" href="#round-ne">Round_ne</a></td>
<td>floating-point round to integral float.</td>
</tr>
<tr><td>27</td>
<td><a class="reference internal" href="#round-ni">Round_ni</a></td>
<td>floating-point round to integral float.</td>
</tr>
<tr><td>28</td>
<td><a class="reference internal" href="#round-pi">Round_pi</a></td>
<td>floating-point round to integral float.</td>
</tr>
<tr><td>29</td>
<td><a class="reference internal" href="#round-z">Round_z</a></td>
<td>floating-point round to integral float.</td>
</tr>
<tr><td>30</td>
<td><a class="reference internal" href="#bfrev">Bfrev</a></td>
<td>Reverses the order of the bits.</td>
</tr>
<tr><td>31</td>
<td><a class="reference internal" href="#countbits">Countbits</a></td>
<td>Counts the number of bits in the input integer.</td>
</tr>
<tr><td>32</td>
<td><a class="reference internal" href="#firstbitlo">FirstbitLo</a></td>
<td>Returns the location of the first set bit starting from the lowest order bit and working upward.</td>
</tr>
<tr><td>33</td>
<td><a class="reference internal" href="#firstbithi">FirstbitHi</a></td>
<td>Returns the location of the first set bit starting from the highest order bit and working downward.</td>
</tr>
<tr><td>34</td>
<td><a class="reference internal" href="#firstbitshi">FirstbitSHi</a></td>
<td>Returns the location of the first set bit from the highest order bit based on the sign.</td>
</tr>
<tr><td>35</td>
<td><a class="reference internal" href="#fmax">FMax</a></td>
<td>returns a if a &gt;= b, else b</td>
</tr>
<tr><td>36</td>
<td><a class="reference internal" href="#fmin">FMin</a></td>
<td>returns a if a &lt; b, else b</td>
</tr>
<tr><td>37</td>
<td><a class="reference internal" href="#imax">IMax</a></td>
<td>IMax(a,b) returns a if a &gt; b, else b</td>
</tr>
<tr><td>38</td>
<td><a class="reference internal" href="#imin">IMin</a></td>
<td>IMin(a,b) returns a if a &lt; b, else b</td>
</tr>
<tr><td>39</td>
<td><a class="reference internal" href="#umax">UMax</a></td>
<td>unsigned integer maximum. UMax(a,b) = a &gt; b ? a : b</td>
</tr>
<tr><td>40</td>
<td><a class="reference internal" href="#umin">UMin</a></td>
<td>unsigned integer minimum. UMin(a,b) = a &lt; b ? a : b</td>
</tr>
<tr><td>41</td>
<td><a class="reference internal" href="#imul">IMul</a></td>
<td>multiply of 32-bit operands to produce the correct full 64-bit result.</td>
</tr>
<tr><td>42</td>
<td><a class="reference internal" href="#umul">UMul</a></td>
<td>multiply of 32-bit operands to produce the correct full 64-bit result.</td>
</tr>
<tr><td>43</td>
<td><a class="reference internal" href="#udiv">UDiv</a></td>
<td>unsigned divide of the 32-bit operand src0 by the 32-bit operand src1.</td>
</tr>
<tr><td>44</td>
<td><a class="reference internal" href="#uaddc">UAddc</a></td>
<td>unsigned add of 32-bit operand with the carry</td>
</tr>
<tr><td>45</td>
<td><a class="reference internal" href="#usubb">USubb</a></td>
<td>unsigned subtract of 32-bit operands with the borrow</td>
</tr>
<tr><td>46</td>
<td><a class="reference internal" href="#fmad">FMad</a></td>
<td>floating point multiply &amp; add</td>
</tr>
<tr><td>47</td>
<td><a class="reference internal" href="#fma">Fma</a></td>
<td>fused multiply-add</td>
</tr>
<tr><td>48</td>
<td><a class="reference internal" href="#imad">IMad</a></td>
<td>Signed integer multiply &amp; add</td>
</tr>
<tr><td>49</td>
<td><a class="reference internal" href="#umad">UMad</a></td>
<td>Unsigned integer multiply &amp; add</td>
</tr>
<tr><td>50</td>
<td><a class="reference internal" href="#msad">Msad</a></td>
<td>masked Sum of Absolute Differences.</td>
</tr>
<tr><td>51</td>
<td><a class="reference internal" href="#ibfe">Ibfe</a></td>
<td>Integer bitfield extract</td>
</tr>
<tr><td>52</td>
<td><a class="reference internal" href="#ubfe">Ubfe</a></td>
<td>Unsigned integer bitfield extract</td>
</tr>
<tr><td>53</td>
<td><a class="reference internal" href="#bfi">Bfi</a></td>
<td>Given a bit range from the LSB of a number, places that number of bits in another number at any offset</td>
</tr>
<tr><td>54</td>
<td><a class="reference internal" href="#dot2">Dot2</a></td>
<td>Two-dimensional vector dot-product</td>
</tr>
<tr><td>55</td>
<td><a class="reference internal" href="#dot3">Dot3</a></td>
<td>Three-dimensional vector dot-product</td>
</tr>
<tr><td>56</td>
<td><a class="reference internal" href="#dot4">Dot4</a></td>
<td>Four-dimensional vector dot-product</td>
</tr>
<tr><td>57</td>
<td>CreateHandle</td>
<td>creates the handle to a resource</td>
</tr>
<tr><td>58</td>
<td>CBufferLoad</td>
<td>loads a value from a constant buffer resource</td>
</tr>
<tr><td>59</td>
<td>CBufferLoadLegacy</td>
<td>loads a value from a constant buffer resource</td>
</tr>
<tr><td>60</td>
<td>Sample</td>
<td>samples a texture</td>
</tr>
<tr><td>61</td>
<td>SampleBias</td>
<td>samples a texture after applying the input bias to the mipmap level</td>
</tr>
<tr><td>62</td>
<td>SampleLevel</td>
<td>samples a texture using a mipmap-level offset</td>
</tr>
<tr><td>63</td>
<td>SampleGrad</td>
<td>samples a texture using a gradient to influence the way the sample location is calculated</td>
</tr>
<tr><td>64</td>
<td>SampleCmp</td>
<td>samples a texture and compares a single component against the specified comparison value</td>
</tr>
<tr><td>65</td>
<td>SampleCmpLevelZero</td>
<td>samples a texture and compares a single component against the specified comparison value</td>
</tr>
<tr><td>66</td>
<td>TextureLoad</td>
<td>reads texel data without any filtering or sampling</td>
</tr>
<tr><td>67</td>
<td>TextureStore</td>
<td>reads texel data without any filtering or sampling</td>
</tr>
<tr><td>68</td>
<td>BufferLoad</td>
<td>reads from a TypedBuffer</td>
</tr>
<tr><td>69</td>
<td>BufferStore</td>
<td>writes to a RWTypedBuffer</td>
</tr>
<tr><td>70</td>
<td>BufferUpdateCounter</td>
<td>atomically increments/decrements the hidden 32-bit counter stored with a Count or Append UAV</td>
</tr>
<tr><td>71</td>
<td>CheckAccessFullyMapped</td>
<td>determines whether all values from a Sample, Gather, or Load operation accessed mapped tiles in a tiled resource</td>
</tr>
<tr><td>72</td>
<td>GetDimensions</td>
<td>gets texture size information</td>
</tr>
<tr><td>73</td>
<td>TextureGather</td>
<td>gathers the four texels that would be used in a bi-linear filtering operation</td>
</tr>
<tr><td>74</td>
<td>TextureGatherCmp</td>
<td>same as TextureGather, except this instrution performs comparison on texels, similar to SampleCmp</td>
</tr>
<tr><td>75</td>
<td>Texture2DMSGetSamplePosition</td>
<td>gets the position of the specified sample</td>
</tr>
<tr><td>76</td>
<td>RenderTargetGetSamplePosition</td>
<td>gets the position of the specified sample</td>
</tr>
<tr><td>77</td>
<td>RenderTargetGetSampleCount</td>
<td>gets the number of samples for a render target</td>
</tr>
<tr><td>78</td>
<td>AtomicBinOp</td>
<td>performs an atomic operation on two operands</td>
</tr>
<tr><td>79</td>
<td>AtomicCompareExchange</td>
<td>atomic compare and exchange to memory</td>
</tr>
<tr><td>80</td>
<td>Barrier</td>
<td>inserts a memory barrier in the shader</td>
</tr>
<tr><td>81</td>
<td>CalculateLOD</td>
<td>calculates the level of detail</td>
</tr>
<tr><td>82</td>
<td>Discard</td>
<td>discard the current pixel</td>
</tr>
<tr><td>83</td>
<td><a class="reference internal" href="#derivcoarsex">DerivCoarseX</a></td>
<td>computes the rate of change per stamp in x direction.</td>
</tr>
<tr><td>84</td>
<td><a class="reference internal" href="#derivcoarsey">DerivCoarseY</a></td>
<td>computes the rate of change per stamp in y direction.</td>
</tr>
<tr><td>85</td>
<td><a class="reference internal" href="#derivfinex">DerivFineX</a></td>
<td>computes the rate of change per pixel in x direction.</td>
</tr>
<tr><td>86</td>
<td><a class="reference internal" href="#derivfiney">DerivFineY</a></td>
<td>computes the rate of change per pixel in y direction.</td>
</tr>
<tr><td>87</td>
<td>EvalSnapped</td>
<td>evaluates an input attribute at pixel center with an offset</td>
</tr>
<tr><td>88</td>
<td>EvalSampleIndex</td>
<td>evaluates an input attribute at a sample location</td>
</tr>
<tr><td>89</td>
<td>EvalCentroid</td>
<td>evaluates an input attribute at pixel center</td>
</tr>
<tr><td>90</td>
<td>SampleIndex</td>
<td>returns the sample index in a sample-frequency pixel shader</td>
</tr>
<tr><td>91</td>
<td>Coverage</td>
<td>returns the coverage mask input in a pixel shader</td>
</tr>
<tr><td>92</td>
<td>InnerCoverage</td>
<td>returns underestimated coverage input from conservative rasterization in a pixel shader</td>
</tr>
<tr><td>93</td>
<td>ThreadId</td>
<td>reads the thread ID</td>
</tr>
<tr><td>94</td>
<td>GroupId</td>
<td>reads the group ID (SV_GroupID)</td>
</tr>
<tr><td>95</td>
<td>ThreadIdInGroup</td>
<td>reads the thread ID within the group (SV_GroupThreadID)</td>
</tr>
<tr><td>96</td>
<td>FlattenedThreadIdInGroup</td>
<td>provides a flattened index for a given thread within a given group (SV_GroupIndex)</td>
</tr>
<tr><td>97</td>
<td>EmitStream</td>
<td>emits a vertex to a given stream</td>
</tr>
<tr><td>98</td>
<td>CutStream</td>
<td>completes the current primitive topology at the specified stream</td>
</tr>
<tr><td>99</td>
<td>EmitThenCutStream</td>
<td>equivalent to an EmitStream followed by a CutStream</td>
</tr>
<tr><td>100</td>
<td>GSInstanceID</td>
<td>GSInstanceID</td>
</tr>
<tr><td>101</td>
<td>MakeDouble</td>
<td>creates a double value</td>
</tr>
<tr><td>102</td>
<td>SplitDouble</td>
<td>splits a double into low and high parts</td>
</tr>
<tr><td>103</td>
<td>LoadOutputControlPoint</td>
<td>LoadOutputControlPoint</td>
</tr>
<tr><td>104</td>
<td>LoadPatchConstant</td>
<td>LoadPatchConstant</td>
</tr>
<tr><td>105</td>
<td>DomainLocation</td>
<td>DomainLocation</td>
</tr>
<tr><td>106</td>
<td>StorePatchConstant</td>
<td>StorePatchConstant</td>
</tr>
<tr><td>107</td>
<td>OutputControlPointID</td>
<td>OutputControlPointID</td>
</tr>
<tr><td>108</td>
<td>PrimitiveID</td>
<td>PrimitiveID</td>
</tr>
<tr><td>109</td>
<td>CycleCounterLegacy</td>
<td>CycleCounterLegacy</td>
</tr>
<tr><td>110</td>
<td>WaveIsFirstLane</td>
<td>returns 1 for the first lane in the wave</td>
</tr>
<tr><td>111</td>
<td>WaveGetLaneIndex</td>
<td>returns the index of the current lane in the wave</td>
</tr>
<tr><td>112</td>
<td>WaveGetLaneCount</td>
<td>returns the number of lanes in the wave</td>
</tr>
<tr><td>113</td>
<td>WaveAnyTrue</td>
<td>returns 1 if any of the lane evaluates the value to true</td>
</tr>
<tr><td>114</td>
<td>WaveAllTrue</td>
<td>returns 1 if all the lanes evaluate the value to true</td>
</tr>
<tr><td>115</td>
<td>WaveActiveAllEqual</td>
<td>returns 1 if all the lanes have the same value</td>
</tr>
<tr><td>116</td>
<td>WaveActiveBallot</td>
<td>returns a struct with a bit set for each lane where the condition is true</td>
</tr>
<tr><td>117</td>
<td>WaveReadLaneAt</td>
<td>returns the value from the specified lane</td>
</tr>
<tr><td>118</td>
<td>WaveReadLaneFirst</td>
<td>returns the value from the first lane</td>
</tr>
<tr><td>119</td>
<td>WaveActiveOp</td>
<td>returns the result the operation across waves</td>
</tr>
<tr><td>120</td>
<td>WaveActiveBit</td>
<td>returns the result of the operation across all lanes</td>
</tr>
<tr><td>121</td>
<td>WavePrefixOp</td>
<td>returns the result of the operation on prior lanes</td>
</tr>
<tr><td>122</td>
<td>QuadReadLaneAt</td>
<td>reads from a lane in the quad</td>
</tr>
<tr><td>123</td>
<td>QuadOp</td>
<td>returns the result of a quad-level operation</td>
</tr>
<tr><td>124</td>
<td>BitcastI16toF16</td>
<td>bitcast between different sizes</td>
</tr>
<tr><td>125</td>
<td>BitcastF16toI16</td>
<td>bitcast between different sizes</td>
</tr>
<tr><td>126</td>
<td>BitcastI32toF32</td>
<td>bitcast between different sizes</td>
</tr>
<tr><td>127</td>
<td>BitcastF32toI32</td>
<td>bitcast between different sizes</td>
</tr>
<tr><td>128</td>
<td>BitcastI64toF64</td>
<td>bitcast between different sizes</td>
</tr>
<tr><td>129</td>
<td>BitcastF64toI64</td>
<td>bitcast between different sizes</td>
</tr>
<tr><td>130</td>
<td>LegacyF32ToF16</td>
<td>legacy fuction to convert float (f32) to half (f16) (this is not related to min-precision)</td>
</tr>
<tr><td>131</td>
<td>LegacyF16ToF32</td>
<td>legacy fuction to convert half (f16) to float (f32) (this is not related to min-precision)</td>
</tr>
<tr><td>132</td>
<td>LegacyDoubleToFloat</td>
<td>legacy fuction to convert double to float</td>
</tr>
<tr><td>133</td>
<td>LegacyDoubleToSInt32</td>
<td>legacy fuction to convert double to int32</td>
</tr>
<tr><td>134</td>
<td>LegacyDoubleToUInt32</td>
<td>legacy fuction to convert double to uint32</td>
</tr>
<tr><td>135</td>
<td>WaveAllBitCount</td>
<td>returns the count of bits set to 1 across the wave</td>
</tr>
<tr><td>136</td>
<td>WavePrefixBitCount</td>
<td>returns the count of bits set to 1 on prior lanes</td>
</tr>
<tr><td>137</td>
<td><a class="reference internal" href="#attributeatvertex">AttributeAtVertex</a></td>
<td>returns the values of the attributes at the vertex.</td>
</tr>
<tr><td>138</td>
<td>ViewID</td>
<td>returns the view index</td>
</tr>
<tr><td>139</td>
<td>RawBufferLoad</td>
<td>reads from a raw buffer and structured buffer</td>
</tr>
<tr><td>140</td>
<td>RawBufferStore</td>
<td>writes to a RWByteAddressBuffer or RWStructuredBuffer</td>
</tr>
<tr><td>141</td>
<td>InstanceID</td>
<td>The user-provided InstanceID on the bottom-level acceleration structure instance within the top-level structure</td>
</tr>
<tr><td>142</td>
<td>InstanceIndex</td>
<td>The autogenerated index of the current instance in the top-level structure</td>
</tr>
<tr><td>143</td>
<td>HitKind</td>
<td>Returns the value passed as HitKind in ReportIntersection().  If intersection was reported by fixed-function triangle intersection, HitKind will be one of HIT_KIND_TRIANGLE_FRONT_FACE or HIT_KIND_TRIANGLE_BACK_FACE.</td>
</tr>
<tr><td>144</td>
<td>RayFlags</td>
<td>uint containing the current ray flags.</td>
</tr>
<tr><td>145</td>
<td>DispatchRaysIndex</td>
<td>The current x and y location within the Width and Height</td>
</tr>
<tr><td>146</td>
<td>DispatchRaysDimensions</td>
<td>The Width and Height values from the D3D12_DISPATCH_RAYS_DESC structure provided to the originating DispatchRays() call.</td>
</tr>
<tr><td>147</td>
<td>WorldRayOrigin</td>
<td>The world-space origin for the current ray.</td>
</tr>
<tr><td>148</td>
<td>WorldRayDirection</td>
<td>The world-space direction for the current ray.</td>
</tr>
<tr><td>149</td>
<td>ObjectRayOrigin</td>
<td>Object-space origin for the current ray.</td>
</tr>
<tr><td>150</td>
<td>ObjectRayDirection</td>
<td>Object-space direction for the current ray.</td>
</tr>
<tr><td>151</td>
<td>ObjectToWorld</td>
<td>Matrix for transforming from object-space to world-space.</td>
</tr>
<tr><td>152</td>
<td>WorldToObject</td>
<td>Matrix for transforming from world-space to object-space.</td>
</tr>
<tr><td>153</td>
<td>RayTMin</td>
<td>float representing the parametric starting point for the ray.</td>
</tr>
<tr><td>154</td>
<td>RayTCurrent</td>
<td>float representing the current parametric ending point for the ray</td>
</tr>
<tr><td>155</td>
<td>IgnoreHit</td>
<td>Used in an any hit shader to reject an intersection and terminate the shader</td>
</tr>
<tr><td>156</td>
<td>AcceptHitAndEndSearch</td>
<td>Used in an any hit shader to abort the ray query and the intersection shader (if any). The current hit is committed and execution passes to the closest hit shader with the closest hit recorded so far</td>
</tr>
<tr><td>157</td>
<td>TraceRay</td>
<td>initiates raytrace</td>
</tr>
<tr><td>158</td>
<td>ReportHit</td>
<td>returns true if hit was accepted</td>
</tr>
<tr><td>159</td>
<td>CallShader</td>
<td>Call a shader in the callable shader table supplied through the DispatchRays() API</td>
</tr>
<tr><td>160</td>
<td>CreateHandleForLib</td>
<td>create resource handle from resource struct for library</td>
</tr>
<tr><td>161</td>
<td>PrimitiveIndex</td>
<td>PrimitiveIndex for raytracing shaders</td>
</tr>
<tr><td>162</td>
<td>Dot2AddHalf</td>
<td>2D half dot product with accumulate to float</td>
</tr>
<tr><td>163</td>
<td>Dot4AddI8Packed</td>
<td>signed dot product of 4 x i8 vectors packed into i32, with accumulate to i32</td>
</tr>
<tr><td>164</td>
<td>Dot4AddU8Packed</td>
<td>unsigned dot product of 4 x u8 vectors packed into i32, with accumulate to i32</td>
</tr>
<tr><td>165</td>
<td>WaveMatch</td>
<td>returns the bitmask of active lanes that have the same value</td>
</tr>
<tr><td>166</td>
<td>WaveMultiPrefixOp</td>
<td>returns the result of the operation on groups of lanes identified by a bitmask</td>
</tr>
<tr><td>167</td>
<td>WaveMultiPrefixBitCount</td>
<td>returns the count of bits set to 1 on groups of lanes identified by a bitmask</td>
</tr>
<tr><td>168</td>
<td>SetMeshOutputCounts</td>
<td>Mesh shader intrinsic SetMeshOutputCounts</td>
</tr>
<tr><td>169</td>
<td>EmitIndices</td>
<td>emit a primitive's vertex indices in a mesh shader</td>
</tr>
<tr><td>170</td>
<td>GetMeshPayload</td>
<td>get the mesh payload which is from amplification shader</td>
</tr>
<tr><td>171</td>
<td>StoreVertexOutput</td>
<td>stores the value to mesh shader vertex output</td>
</tr>
<tr><td>172</td>
<td>StorePrimitiveOutput</td>
<td>stores the value to mesh shader primitive output</td>
</tr>
<tr><td>173</td>
<td>DispatchMesh</td>
<td>Amplification shader intrinsic DispatchMesh</td>
</tr>
<tr><td>174</td>
<td>WriteSamplerFeedback</td>
<td>updates a feedback texture for a sampling operation</td>
</tr>
<tr><td>175</td>
<td>WriteSamplerFeedbackBias</td>
<td>updates a feedback texture for a sampling operation with a bias on the mipmap level</td>
</tr>
<tr><td>176</td>
<td>WriteSamplerFeedbackLevel</td>
<td>updates a feedback texture for a sampling operation with a mipmap-level offset</td>
</tr>
<tr><td>177</td>
<td>WriteSamplerFeedbackGrad</td>
<td>updates a feedback texture for a sampling operation with explicit gradients</td>
</tr>
<tr><td>178</td>
<td>AllocateRayQuery</td>
<td>allocates space for RayQuery and return handle</td>
</tr>
<tr><td>179</td>
<td>RayQuery_TraceRayInline</td>
<td>initializes RayQuery for raytrace</td>
</tr>
<tr><td>180</td>
<td>RayQuery_Proceed</td>
<td>advances a ray query</td>
</tr>
<tr><td>181</td>
<td>RayQuery_Abort</td>
<td>aborts a ray query</td>
</tr>
<tr><td>182</td>
<td>RayQuery_CommitNonOpaqueTriangleHit</td>
<td>commits a non opaque triangle hit</td>
</tr>
<tr><td>183</td>
<td>RayQuery_CommitProceduralPrimitiveHit</td>
<td>commits a procedural primitive hit</td>
</tr>
<tr><td>184</td>
<td>RayQuery_CommittedStatus</td>
<td>returns uint status (COMMITTED_STATUS) of the committed hit in a ray query</td>
</tr>
<tr><td>185</td>
<td>RayQuery_CandidateType</td>
<td>returns uint candidate type (CANDIDATE_TYPE) of the current hit candidate in a ray query, after Proceed() has returned true</td>
</tr>
<tr><td>186</td>
<td>RayQuery_CandidateObjectToWorld3x4</td>
<td>returns matrix for transforming from object-space to world-space for a candidate hit.</td>
</tr>
<tr><td>187</td>
<td>RayQuery_CandidateWorldToObject3x4</td>
<td>returns matrix for transforming from world-space to object-space for a candidate hit.</td>
</tr>
<tr><td>188</td>
<td>RayQuery_CommittedObjectToWorld3x4</td>
<td>returns matrix for transforming from object-space to world-space for a Committed hit.</td>
</tr>
<tr><td>189</td>
<td>RayQuery_CommittedWorldToObject3x4</td>
<td>returns matrix for transforming from world-space to object-space for a Committed hit.</td>
</tr>
<tr><td>190</td>
<td>RayQuery_CandidateProceduralPrimitiveNonOpaque</td>
<td>returns if current candidate procedural primitive is non opaque</td>
</tr>
<tr><td>191</td>
<td>RayQuery_CandidateTriangleFrontFace</td>
<td>returns if current candidate triangle is front facing</td>
</tr>
<tr><td>192</td>
<td>RayQuery_CommittedTriangleFrontFace</td>
<td>returns if current committed triangle is front facing</td>
</tr>
<tr><td>193</td>
<td>RayQuery_CandidateTriangleBarycentrics</td>
<td>returns candidate triangle hit barycentrics</td>
</tr>
<tr><td>194</td>
<td>RayQuery_CommittedTriangleBarycentrics</td>
<td>returns committed triangle hit barycentrics</td>
</tr>
<tr><td>195</td>
<td>RayQuery_RayFlags</td>
<td>returns ray flags</td>
</tr>
<tr><td>196</td>
<td>RayQuery_WorldRayOrigin</td>
<td>returns world ray origin</td>
</tr>
<tr><td>197</td>
<td>RayQuery_WorldRayDirection</td>
<td>returns world ray direction</td>
</tr>
<tr><td>198</td>
<td>RayQuery_RayTMin</td>
<td>returns float representing the parametric starting point for the ray.</td>
</tr>
<tr><td>199</td>
<td>RayQuery_CandidateTriangleRayT</td>
<td>returns float representing the parametric point on the ray for the current candidate triangle hit.</td>
</tr>
<tr><td>200</td>
<td>RayQuery_CommittedRayT</td>
<td>returns float representing the parametric point on the ray for the current committed hit.</td>
</tr>
<tr><td>201</td>
<td>RayQuery_CandidateInstanceIndex</td>
<td>returns candidate hit instance index</td>
</tr>
<tr><td>202</td>
<td>RayQuery_CandidateInstanceID</td>
<td>returns candidate hit instance ID</td>
</tr>
<tr><td>203</td>
<td>RayQuery_CandidateGeometryIndex</td>
<td>returns candidate hit geometry index</td>
</tr>
<tr><td>204</td>
<td>RayQuery_CandidatePrimitiveIndex</td>
<td>returns candidate hit geometry index</td>
</tr>
<tr><td>205</td>
<td>RayQuery_CandidateObjectRayOrigin</td>
<td>returns candidate hit object ray origin</td>
</tr>
<tr><td>206</td>
<td>RayQuery_CandidateObjectRayDirection</td>
<td>returns candidate object ray direction</td>
</tr>
<tr><td>207</td>
<td>RayQuery_CommittedInstanceIndex</td>
<td>returns committed hit instance index</td>
</tr>
<tr><td>208</td>
<td>RayQuery_CommittedInstanceID</td>
<td>returns committed hit instance ID</td>
</tr>
<tr><td>209</td>
<td>RayQuery_CommittedGeometryIndex</td>
<td>returns committed hit geometry index</td>
</tr>
<tr><td>210</td>
<td>RayQuery_CommittedPrimitiveIndex</td>
<td>returns committed hit geometry index</td>
</tr>
<tr><td>211</td>
<td>RayQuery_CommittedObjectRayOrigin</td>
<td>returns committed hit object ray origin</td>
</tr>
<tr><td>212</td>
<td>RayQuery_CommittedObjectRayDirection</td>
<td>returns committed object ray direction</td>
</tr>
<tr><td>213</td>
<td>GeometryIndex</td>
<td>The autogenerated index of the current geometry in the bottom-level structure</td>
</tr>
<tr><td>214</td>
<td>RayQuery_CandidateInstanceContributionToHitGroupIndex</td>
<td>returns candidate hit InstanceContributionToHitGroupIndex</td>
</tr>
<tr><td>215</td>
<td>RayQuery_CommittedInstanceContributionToHitGroupIndex</td>
<td>returns committed hit InstanceContributionToHitGroupIndex</td>
</tr>
<tr><td>216</td>
<td>AnnotateHandle</td>
<td>annotate handle with resource properties</td>
</tr>
<tr><td>217</td>
<td>CreateHandleFromBinding</td>
<td>create resource handle from binding</td>
</tr>
<tr><td>218</td>
<td>CreateHandleFromHeap</td>
<td>create resource handle from heap</td>
</tr>
<tr><td>219</td>
<td>Unpack4x8</td>
<td>unpacks 4 8-bit signed or unsigned values into int32 or int16 vector</td>
</tr>
<tr><td>220</td>
<td>Pack4x8</td>
<td>packs vector of 4 signed or unsigned values into a packed datatype, drops or clamps unused bits</td>
</tr>
<tr><td>221</td>
<td>IsHelperLane</td>
<td>returns true on helper lanes in pixel shaders</td>
</tr>
<tr><td>222</td>
<td>QuadVote</td>
<td>compares boolean accross a quad</td>
</tr>
<tr><td>223</td>
<td>TextureGatherRaw</td>
<td>Gather raw elements from 4 texels with no type conversions (SRV type is constrained)</td>
</tr>
<tr><td>224</td>
<td>SampleCmpLevel</td>
<td>samples a texture and compares a single component against the specified comparison value</td>
</tr>
<tr><td>225</td>
<td>TextureStoreSample</td>
<td>stores texel data at specified sample index</td>
</tr>
<tr><td>226</td>
<td>WaveMatrix_Annotate</td>
<td>Annotate a wave matrix pointer with the type information</td>
</tr>
<tr><td>227</td>
<td>WaveMatrix_Depth</td>
<td>Returns depth (K) value for matrix of specified type</td>
</tr>
<tr><td>228</td>
<td>WaveMatrix_Fill</td>
<td>Fill wave matrix with scalar value</td>
</tr>
<tr><td>229</td>
<td>WaveMatrix_LoadRawBuf</td>
<td>Load wave matrix from raw buffer</td>
</tr>
<tr><td>230</td>
<td>WaveMatrix_LoadGroupShared</td>
<td>Load wave matrix from group shared array</td>
</tr>
<tr><td>231</td>
<td>WaveMatrix_StoreRawBuf</td>
<td>Store wave matrix to raw buffer</td>
</tr>
<tr><td>232</td>
<td>WaveMatrix_StoreGroupShared</td>
<td>Store wave matrix to group shared array</td>
</tr>
<tr><td>233</td>
<td>WaveMatrix_Multiply</td>
<td>Mutiply left and right wave matrix and store in accumulator</td>
</tr>
<tr><td>234</td>
<td>WaveMatrix_MultiplyAccumulate</td>
<td>Mutiply left and right wave matrix and accumulate into accumulator</td>
</tr>
<tr><td>235</td>
<td>WaveMatrix_ScalarOp</td>
<td>Perform scalar operation on each element of wave matrix</td>
</tr>
<tr><td>236</td>
<td>WaveMatrix_SumAccumulate</td>
<td>Sum rows or columns of an input matrix into an existing accumulator fragment matrix</td>
</tr>
<tr><td>237</td>
<td>WaveMatrix_Add</td>
<td>Element-wise accumulate, or broadcast add of fragment into accumulator</td>
</tr>
<tr><td>238</td>
<td>AllocateNodeOutputRecords</td>
<td>returns a handle for the output records</td>
</tr>
<tr><td>239</td>
<td>GetNodeRecordPtr</td>
<td>retrieve node input/output record pointer in address space 6</td>
</tr>
<tr><td>240</td>
<td>IncrementOutputCount</td>
<td>Select the next logical output count for an EmptyNodeOutput for the whole group or per thread.</td>
</tr>
<tr><td>241</td>
<td>OutputComplete</td>
<td>indicates all outputs for a given records are complete</td>
</tr>
<tr><td>242</td>
<td>GetInputRecordCount</td>
<td>returns the number of records that have been coalesced into the current thread group</td>
</tr>
<tr><td>243</td>
<td>FinishedCrossGroupSharing</td>
<td>returns true if the current thread group is the last to access the input</td>
</tr>
<tr><td>244</td>
<td>BarrierByMemoryType</td>
<td>Request a barrier for a set of memory types and/or thread group execution sync</td>
</tr>
<tr><td>245</td>
<td>BarrierByMemoryHandle</td>
<td>Request a barrier for just the memory used by the specified object</td>
</tr>
<tr><td>246</td>
<td>BarrierByNodeRecordHandle</td>
<td>Request a barrier for just the memory used by the node record</td>
</tr>
<tr><td>247</td>
<td>CreateNodeOutputHandle</td>
<td>Creates a handle to a NodeOutput</td>
</tr>
<tr><td>248</td>
<td>IndexNodeHandle</td>
<td>returns the handle for the location in the output node array at the indicated index</td>
</tr>
<tr><td>249</td>
<td>AnnotateNodeHandle</td>
<td>annotate handle with node properties</td>
</tr>
<tr><td>250</td>
<td>CreateNodeInputRecordHandle</td>
<td>create a handle for an InputRecord</td>
</tr>
<tr><td>251</td>
<td>AnnotateNodeRecordHandle</td>
<td>annotate handle with node record properties</td>
</tr>
<tr><td>252</td>
<td>NodeOutputIsValid</td>
<td>returns true if the specified output node is present in the work graph</td>
</tr>
<tr><td>253</td>
<td>GetRemainingRecursionLevels</td>
<td>returns how many levels of recursion remain</td>
</tr>
<tr><td>254</td>
<td>SampleCmpGrad</td>
<td>samples a texture using a gradient and compares a single component against the specified comparison value</td>
</tr>
<tr><td>255</td>
<td>SampleCmpBias</td>
<td>samples a texture after applying the input bias to the mipmap level and compares a single component against the specified comparison value</td>
</tr>
<tr><td>256</td>
<td>StartVertexLocation</td>
<td>returns the BaseVertexLocation from DrawIndexedInstanced or StartVertexLocation from DrawInstanced</td>
</tr>
<tr><td>257</td>
<td>StartInstanceLocation</td>
<td>returns the StartInstanceLocation from Draw*Instanced</td>
</tr>
</tbody>
</table>
<a name="acos"></a>
<h4>Acos</h4>
<p>The return value is within the range of -PI/2 to PI/2.</p>
<table class="docutils">
<colgroup>
<col width="14%" />
<col width="8%" />
<col width="20%" />
<col width="13%" />
<col width="8%" />
<col width="8%" />
<col width="13%" />
<col width="8%" />
<col width="7%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>[-1,1]</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>acos(src)</td>
<td>NaN</td>
<td>(-PI/2,+PI/2)</td>
<td>PI/2</td>
<td>PI/2</td>
<td>PI/2</td>
<td>PI/2</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="asin"></a>
<h4>Asin</h4>
<p>The return value is within the range of -PI/2 to PI/2.</p>
<table class="docutils">
<colgroup>
<col width="14%" />
<col width="8%" />
<col width="20%" />
<col width="13%" />
<col width="8%" />
<col width="8%" />
<col width="13%" />
<col width="8%" />
<col width="7%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>[-1,1]</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>asin(src)</td>
<td>NaN</td>
<td>(-PI/2,+PI/2)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="atan"></a>
<h4>Atan</h4>
<table class="docutils">
<colgroup>
<col width="12%" />
<col width="7%" />
<col width="16%" />
<col width="11%" />
<col width="7%" />
<col width="7%" />
<col width="11%" />
<col width="18%" />
<col width="6%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>atan(src)</td>
<td>-PI/2</td>
<td>(-PI/2,+PI/2)</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>(-PI/2,+PI/2)</td>
<td>PI/2</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p>Returns the arctangent of the specified value. The return value is within the range of -PI/2 to PI/2</p>
<a name="attributeatvertex"></a>
<h4>AttributeAtVertex</h4>
<p>returns the values of the attributes at the vertex. VertexID ranges from 0 to 2.</p>
<a name="bfi"></a>
<h4>Bfi</h4>
<p>Given a bit range from the LSB of a number, place that number of bits in another number at any offset.</p>
<p>dst = Bfi(src0, src1, src2, src3);</p>
<p>The LSB 5 bits of src0 provide the bitfield width (0-31) to take from src2.
The LSB 5 bits of src1 provide the bitfield offset (0-31) to start replacing bits in the  number read from src3.
Given width, offset: bitmask = (((1 &lt;&lt; width)-1) &lt;&lt; offset) &amp; 0xffffffff, dest = ((src2 &lt;&lt; offset) &amp; bitmask) | (src3 &amp; ~bitmask)</p>
<a name="bfrev"></a>
<h4>Bfrev</h4>
<p>Reverses the order of the bits. For example given 0x12345678 the result would be 0x1e6a2c48.</p>
<a name="cos"></a>
<h4>Cos</h4>
<p>Theta values can be any IEEE 32-bit floating point values.</p>
<p>The maximum absolute error is 0.0008 in the interval from -100*Pi to +100*Pi.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="16%" />
<col width="12%" />
<col width="5%" />
<col width="5%" />
<col width="12%" />
<col width="16%" />
<col width="8%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>cos(src)</td>
<td>NaN</td>
<td>[-1 to +1]</td>
<td>+1</td>
<td>+1</td>
<td>+1</td>
<td>+1</td>
<td>[-1 to +1]</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="countbits"></a>
<h4>Countbits</h4>
<p>Counts the number of bits in the input integer.</p>
<a name="derivcoarsex"></a>
<h4>DerivCoarseX</h4>
<p>dst = DerivCoarseX(src);</p>
<p>Computes the rate of change per stamp in x direction. Only a single x derivative pair is computed for each 2x2 stamp of pixels.
The data in the current Pixel Shader invocation may or may not participate in the calculation of the requested derivative, given the derivative will be calculated only once per 2x2 quad:
As an example, the x derivative could be a delta from the top row of pixels.
The exact calculation is up to the hardware vendor. There is also no specification dictating how the 2x2 quads will be aligned/tiled over a primitive.</p>
<a name="derivcoarsey"></a>
<h4>DerivCoarseY</h4>
<p>dst = DerivCoarseY(src);</p>
<p>Computes the rate of change per stamp in y direction. Only a single y derivative pair is computed for each 2x2 stamp of pixels.
The data in the current Pixel Shader invocation may or may not participate in the calculation of the requested derivative, given the derivative will be calculated only once per 2x2 quad:
As an example, the y derivative could be a delta from the left column of pixels.
The exact calculation is up to the hardware vendor. There is also no specification dictating how the 2x2 quads will be aligned/tiled over a primitive.</p>
<a name="derivfinex"></a>
<h4>DerivFineX</h4>
<p>dst = DerivFineX(src);</p>
<p>Computes the rate of change per pixel in x direction. Each pixel in the 2x2 stamp gets a unique pair of x derivative calculations
The data in the current Pixel Shader invocation always participates in the calculation of the requested derivative.
There is no specification dictating how the 2x2 quads will be aligned/tiled over a primitive.</p>
<a name="derivfiney"></a>
<h4>DerivFineY</h4>
<p>dst = DerivFineY(src);</p>
<p>Computes the rate of change per pixel in y direction. Each pixel in the 2x2 stamp gets a unique pair of y derivative calculations
The data in the current Pixel Shader invocation always participates in the calculation of the requested derivative.
There is no specification dictating how the 2x2 quads will be aligned/tiled over a primitive.</p>
<a name="dot2"></a>
<h4>Dot2</h4>
<p>Two-dimensional vector dot-product</p>
<a name="dot3"></a>
<h4>Dot3</h4>
<p>Three-dimensional vector dot-product</p>
<a name="dot4"></a>
<h4>Dot4</h4>
<p>Four-dimensional vector dot-product</p>
<a name="exp"></a>
<h4>Exp</h4>
<p>Returns 2^exponent. Note that hlsl log intrinsic returns the base-e exponent. Maximum relative error is e^-21.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="16%" />
<col width="12%" />
<col width="5%" />
<col width="5%" />
<col width="12%" />
<col width="16%" />
<col width="8%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>exp(src)</td>
<td>0</td>
<td>+F</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="fabs"></a>
<h4>FAbs</h4>
<p>The FAbs instruction takes simply forces the sign of the number(s) on the source operand positive, including on INF and denorm values.
Applying FAbs on NaN preserves NaN, although the particular NaN bit pattern that results is not defined.</p>
<a name="fmad"></a>
<h4>FMad</h4>
<p>Floating point multiply &amp; add. This operation is not fused for &quot;precise&quot; operations.
FMad(a,b,c) = a * b + c</p>
<a name="fmax"></a>
<h4>FMax</h4>
<p>&gt;= is used instead of &gt; so that if min(x,y) = x then max(x,y) = y.</p>
<p>NaN has special handling: If one source operand is NaN, then the other source operand is returned.
If both are NaN, any NaN representation is returned.
This conforms to new IEEE 754R rules.</p>
<p>Denorms are flushed (sign preserved) before comparison, however the result written to dest may or may not be denorm flushed.</p>
<table class="docutils">
<colgroup>
<col width="19%" />
<col width="19%" />
<col width="25%" />
<col width="19%" />
<col width="19%" />
</colgroup>
<tbody valign="top">
<tr><td rowspan="2">a</td>
<td colspan="4">b</td>
</tr>
<tr><td>-inf</td>
<td>F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>-inf</td>
<td>-inf</td>
<td>b</td>
<td>+inf</td>
<td>-inf</td>
</tr>
<tr><td>F</td>
<td>a</td>
<td>a or b</td>
<td>+inf</td>
<td>a</td>
</tr>
<tr><td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
<td>+inf</td>
</tr>
<tr><td>NaN</td>
<td>-inf</td>
<td>b</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="fmin"></a>
<h4>FMin</h4>
<p>NaN has special handling: If one source operand is NaN, then the other source operand is returned.
If both are NaN, any NaN representation is returned.
This conforms to new IEEE 754R rules.</p>
<p>Denorms are flushed (sign preserved) before comparison, however the result written to dest may or may not be denorm flushed.</p>
<table class="docutils">
<colgroup>
<col width="19%" />
<col width="19%" />
<col width="25%" />
<col width="19%" />
<col width="19%" />
</colgroup>
<tbody valign="top">
<tr><td rowspan="2">a</td>
<td colspan="4">b</td>
</tr>
<tr><td>-inf</td>
<td>F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
</tr>
<tr><td>F</td>
<td>-inf</td>
<td>a or b</td>
<td>a</td>
<td>a</td>
</tr>
<tr><td>+inf</td>
<td>-inf</td>
<td>b</td>
<td>+inf</td>
<td>+inf</td>
</tr>
<tr><td>NaN</td>
<td>-inf</td>
<td>b</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="firstbithi"></a>
<h4>FirstbitHi</h4>
<p>Returns the integer position of the first bit set in the 32-bit input starting from the MSB. For example, 0x10000000 would return 3. Returns 0xffffffff if no match was found.</p>
<a name="firstbitlo"></a>
<h4>FirstbitLo</h4>
<p>Returns the integer position of the first bit set in the 32-bit input starting from the LSB. For example, 0x00000000 would return 1. Returns 0xffffffff if no match was found.</p>
<a name="firstbitshi"></a>
<h4>FirstbitSHi</h4>
<p>Returns the first 0 from the MSB if the number is negative, else the first 1 from the MSB. Returns 0xffffffff if no match was found.</p>
<a name="fma"></a>
<h4>Fma</h4>
<p>Fused multiply-add. This operation is only defined in double precision.
Fma(a,b,c) = a * b + c</p>
<a name="frc"></a>
<h4>Frc</h4>
<table class="docutils">
<colgroup>
<col width="20%" />
<col width="8%" />
<col width="8%" />
<col width="13%" />
<col width="6%" />
<col width="6%" />
<col width="13%" />
<col width="11%" />
<col width="8%" />
<col width="7%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>log(src)</td>
<td>NaN</td>
<td>[+0,1)</td>
<td>+0</td>
<td>+0</td>
<td>+0</td>
<td>+0</td>
<td>[+0,1)</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="hcos"></a>
<h4>Hcos</h4>
<p>Returns the hyperbolic cosine of the specified value.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="16%" />
<col width="12%" />
<col width="5%" />
<col width="5%" />
<col width="12%" />
<col width="16%" />
<col width="8%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>hcos(src)</td>
<td>+inf</td>
<td>(1, +inf)</td>
<td>+1</td>
<td>+1</td>
<td>+1</td>
<td>+1</td>
<td>(1, +inf)</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="hsin"></a>
<h4>Hsin</h4>
<p>Returns the hyperbolic sine of the specified value.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="16%" />
<col width="12%" />
<col width="5%" />
<col width="5%" />
<col width="12%" />
<col width="16%" />
<col width="8%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>hsin(src)</td>
<td>-inf</td>
<td>-F</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="htan"></a>
<h4>Htan</h4>
<p>Returns the hyperbolic tangent of the specified value.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="16%" />
<col width="12%" />
<col width="5%" />
<col width="5%" />
<col width="12%" />
<col width="16%" />
<col width="8%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>htan(src)</td>
<td>-1</td>
<td>-F</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>+F</td>
<td>+1</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="imad"></a>
<h4>IMad</h4>
<p>Signed integer multiply &amp; add</p>
<p>IMad(a,b,c) = a * b + c</p>
<a name="imax"></a>
<h4>IMax</h4>
<p>IMax(a,b) returns a if a &gt; b, else b. Optional negate modifier on source operands takes 2's complement before performing operation.</p>
<a name="imin"></a>
<h4>IMin</h4>
<p>IMin(a,b) returns a if a &lt; b, else b. Optional negate modifier on source operands takes 2's complement before performing operation.</p>
<a name="imul"></a>
<h4>IMul</h4>
<p>IMul(src0, src1) = destHi, destLo
multiply of 32-bit operands src0 and src1 (note they are signed), producing the correct full 64-bit result.
The low 32 bits are placed in destLO. The high 32 bits are placed in destHI.</p>
<p>Either of destHI or destLO may be specified as NULL instead of specifying a register, in the case high or low 32 bits of the 64-bit result are not needed.</p>
<p>Optional negate modifier on source operands takes 2's complement before performing arithmetic operation.</p>
<a name="ibfe"></a>
<h4>Ibfe</h4>
<p>dest = Ibfe(src0, src1, src2)</p>
<p>Given a range of bits in a number, shift those bits to the LSB and sign extend the MSB of the range.</p>
<p>width : The LSB 5 bits of src0 (0-31).</p>
<p>offset: The LSB 5 bits of src1 (0-31)</p>
<pre lang="text">
if( width == 0 )
{
    dest = 0
}
else if( width + offset &lt; 32 )
{
    shl dest, src2, 32-(width+offset)
    ishr dest, dest, 32-width
}
else
{
    ishr dest, src2, offset
}
</pre>
<a name="isfinite"></a>
<h4>IsFinite</h4>
<p>Returns true if x is finite, false otherwise.</p>
<a name="isinf"></a>
<h4>IsInf</h4>
<p>Returns true if x is +INF or -INF, false otherwise.</p>
<a name="isnan"></a>
<h4>IsNaN</h4>
<p>Returns true if x is NAN or QNAN, false otherwise.</p>
<a name="isnormal"></a>
<h4>IsNormal</h4>
<p>Returns IsNormal.</p>
<a name="loadinput"></a>
<h4>LoadInput</h4>
<p>Loads the value from shader input</p>
<a name="log"></a>
<h4>Log</h4>
<p>Returns log base 2. Note that hlsl log intrinsic returns natural log.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="16%" />
<col width="12%" />
<col width="5%" />
<col width="5%" />
<col width="12%" />
<col width="16%" />
<col width="8%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>log(src)</td>
<td>NaN</td>
<td>NaN</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>-inf</td>
<td>F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="minprecxregload"></a>
<h4>MinPrecXRegLoad</h4>
<p>Helper load operation for minprecision</p>
<a name="minprecxregstore"></a>
<h4>MinPrecXRegStore</h4>
<p>Helper store operation for minprecision</p>
<a name="msad"></a>
<h4>Msad</h4>
<p>Returns the masked Sum of Absolute Differences.</p>
<p>dest = msad(ref, src, accum)</p>
<p>ref: contains 4 packed 8-bit unsigned integers in 32 bits.</p>
<p>src: contains 4 packed 8-bit unsigned integers in 32 bits.</p>
<p>accum: a 32-bit unsigned integer, providing an existing accumulation.</p>
<p>dest receives the result of the masked SAD operation added to the accumulation value.</p>
<pre lang="text">
UINT msad( UINT ref, UINT src, UINT accum )
{
    for (UINT i = 0; i &lt; 4; i++)
    {
        BYTE refByte, srcByte, absDiff;

        refByte = (BYTE)(ref &gt;&gt; (i * 8));
        if (!refByte)
        {
            continue;
        }

        srcByte = (BYTE)(src &gt;&gt; (i * 8));
        if (refByte &gt;= srcByte)
        {
            absDiff = refByte - srcByte;
        }
        else
        {
            absDiff = srcByte - refByte;
        }

        // The recommended overflow behavior for MSAD is
        // to do a 32-bit saturate. This is not
        // required, however, and wrapping is allowed.
        // So from an application point of view,
        // overflow behavior is undefined.
        if (UINT_MAX - accum &lt; absDiff)
        {
            accum = UINT_MAX;
            break;
        }

        accum += absDiff;
    }

    return accum;
}
</pre>
<a name="round-ne"></a>
<h4>Round_ne</h4>
<p>Floating-point round of the values in src,
writing integral floating-point values to dest.</p>
<p>round_ne rounds towards nearest even. For halfway, it rounds away from zero.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="9%" />
<col width="8%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>round_ne(src)</td>
<td>-inf</td>
<td>-F</td>
<td>-0</td>
<td>-0</td>
<td>+0</td>
<td>+0</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="round-ni"></a>
<h4>Round_ni</h4>
<p>Floating-point round of the values in src,
writing integral floating-point values to dest.</p>
<p>round_ni rounds towards -INF, commonly known as floor().</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="9%" />
<col width="8%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>round_ni(src)</td>
<td>-inf</td>
<td>-F</td>
<td>-0</td>
<td>-0</td>
<td>+0</td>
<td>+0</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="round-pi"></a>
<h4>Round_pi</h4>
<p>Floating-point round of the values in src,
writing integral floating-point values to dest.</p>
<p>round_pi rounds towards +INF, commonly known as ceil().</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="9%" />
<col width="8%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>round_pi(src)</td>
<td>-inf</td>
<td>-F</td>
<td>-0</td>
<td>-0</td>
<td>+0</td>
<td>+0</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="round-z"></a>
<h4>Round_z</h4>
<p>Floating-point round of the values in src,
writing integral floating-point values to dest.</p>
<p>round_z rounds towards zero.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="9%" />
<col width="8%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>round_z(src)</td>
<td>-inf</td>
<td>-F</td>
<td>-0</td>
<td>-0</td>
<td>+0</td>
<td>+0</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="rsqrt"></a>
<h4>Rsqrt</h4>
<p>Maximum relative error is 2^21.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="9%" />
<col width="8%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>rsqrt(src)</td>
<td>-inf</td>
<td>-F</td>
<td>-0</td>
<td>-0</td>
<td>+0</td>
<td>+0</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="saturate"></a>
<h4>Saturate</h4>
<p>The Saturate instruction performs the following operation on its input value:</p>
<p>min(1.0f, max(0.0f, value))</p>
<p>where min() and max() in the above expression behave in the way Min and Max behave.</p>
<p>Saturate(NaN) returns 0, by the rules for min and max.</p>
<a name="sin"></a>
<h4>Sin</h4>
<p>Theta values can be any IEEE 32-bit floating point values.</p>
<p>The maximum absolute error is 0.0008 in the interval from -100*Pi to +100*Pi.</p>
<table class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="16%" />
<col width="12%" />
<col width="5%" />
<col width="5%" />
<col width="12%" />
<col width="16%" />
<col width="8%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>sin(src)</td>
<td>NaN</td>
<td>[-1 to +1]</td>
<td>-0</td>
<td>-0</td>
<td>+0</td>
<td>+0</td>
<td>[-1 to +1]</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="sqrt"></a>
<h4>Sqrt</h4>
<p>Precision is 1 ulp.</p>
<table class="docutils">
<colgroup>
<col width="22%" />
<col width="9%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="6%" />
<col width="14%" />
<col width="6%" />
<col width="9%" />
<col width="8%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>sqrt(src)</td>
<td>NaN</td>
<td>NaN</td>
<td>-0</td>
<td>-0</td>
<td>+0</td>
<td>+0</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="storeoutput"></a>
<h4>StoreOutput</h4>
<p>Stores the value to shader output</p>
<a name="tan"></a>
<h4>Tan</h4>
<p>Theta values can be any IEEE 32-bit floating point values.</p>
<table class="docutils">
<colgroup>
<col width="11%" />
<col width="11%" />
<col width="18%" />
<col width="10%" />
<col width="4%" />
<col width="4%" />
<col width="10%" />
<col width="18%" />
<col width="7%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr><td>src</td>
<td>-inf</td>
<td>-F</td>
<td>-denorm</td>
<td>-0</td>
<td>+0</td>
<td>+denorm</td>
<td>+F</td>
<td>+inf</td>
<td>NaN</td>
</tr>
<tr><td>tan(src)</td>
<td>NaN</td>
<td>[-inf to +inf]</td>
<td>-0</td>
<td>-0</td>
<td>+0</td>
<td>+0</td>
<td>[-inf to +inf]</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<a name="tempregload"></a>
<h4>TempRegLoad</h4>
<p>Helper load operation</p>
<a name="tempregstore"></a>
<h4>TempRegStore</h4>
<p>Helper store operation</p>
<a name="uaddc"></a>
<h4>UAddc</h4>
<p>dest0, dest1 = UAddc(src0, src1)</p>
<p>unsigned add of 32-bit operands src0 and src1, placing the LSB part of the 32-bit result in dest0.
dest1 is written with: 1 if a carry is produced, 0 otherwise. Dest1 can be NULL if the carry is not needed</p>
<a name="udiv"></a>
<h4>UDiv</h4>
<p>destQUOT, destREM = UDiv(src0, src1);</p>
<p>unsigned divide of the 32-bit operand src0 by the 32-bit operand src1.</p>
<p>The results of the divides are the 32-bit quotients (placed in destQUOT) and 32-bit remainders (placed in destREM).</p>
<p>Divide by zero returns 0xffffffff for both quotient and remainder.</p>
<p>Either destQUOT or destREM may be specified as NULL instead of specifying a register, in the case the quotient or remainder are not needed.</p>
<p>Unsigned subtract of 32-bit operands src1 from src0, placing the LSB part of the 32-bit result in dest0.
dest1 is written with: 1 if a borrow is produced, 0 otherwise. Dest1 can be NULL if the borrow is not needed</p>
<a name="umad"></a>
<h4>UMad</h4>
<p>Unsigned integer multiply &amp; add.</p>
<p>Umad(a,b,c) = a * b + c</p>
<a name="umax"></a>
<h4>UMax</h4>
<p>unsigned integer maximum. UMax(a,b) = a &gt; b ? a : b</p>
<a name="umin"></a>
<h4>UMin</h4>
<p>unsigned integer minimum. UMin(a,b) = a &lt; b ? a : b</p>
<a name="umul"></a>
<h4>UMul</h4>
<p>multiply of 32-bit operands src0 and src1 (note they are unsigned), producing the correct full 64-bit result.
The low 32 bits are placed in destLO. The high 32 bits are placed in destHI.
Either of destHI or destLO may be specified as NULL instead of specifying a register, in the case high or low 32 bits of the 64-bit result are not needed</p>
<a name="usubb"></a>
<h4>USubb</h4>
<p>dest0, dest1 = USubb(src0, src1)</p>
<a name="ubfe"></a>
<h4>Ubfe</h4>
<p>dest = ubfe(src0, src1, src2)</p>
<p>Given a range of bits in a number, shift those bits to the LSB and set remaining bits to 0.</p>
<p>width : The LSB 5 bits of src0 (0-31).</p>
<p>offset: The LSB 5 bits of src1 (0-31).</p>
<p>Given width, offset:</p>
<pre lang="text">
if( width == 0 )
{
    dest = 0
}
else if( width + offset &lt; 32 )
{
    shl dest, src2, 32-(width+offset)
    ushr dest, dest, 32-width
}
else
{
    ushr dest, src2, offset
}
</pre>
<a name="custom-instructions"></a>
<h3><a class="toc-backref" href="#toc-entry-59">Custom instructions</a></h3>
<p>Instructions for third-party extensions will be specially-prefixed external function calls, identified by a declared extension-set-prefix. Additional metadata will be included to provide hints about uniformity, pure or const guarantees, alignment, etc.</p>
<a name="validation-rules"></a>
<h2><a class="toc-backref" href="#toc-entry-60">Validation Rules</a></h2>
<p>The following rules are verified by the <em>Validator</em> component and thus can be relied upon by downstream consumers.</p>
<p>The set of validation rules that are known to hold for a DXIL program is identifier by the 'dx.valver' named metadata node, which consists of a two-element tuple of constant int values, a major and minor version. Minor version numbers are increments as rules are added to a prior table or as the implementation fixes issues.</p>
<table class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Rule Code</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>BITCODE.VALID</td>
<td>Module must be bitcode-valid</td>
</tr>
<tr><td>CONTAINER.PARTINVALID</td>
<td>DXIL Container must not contain unknown parts</td>
</tr>
<tr><td>CONTAINER.PARTMATCHES</td>
<td>DXIL Container Parts must match Module</td>
</tr>
<tr><td>CONTAINER.PARTMISSING</td>
<td>DXIL Container requires certain parts, corresponding to module</td>
</tr>
<tr><td>CONTAINER.PARTREPEATED</td>
<td>DXIL Container must have only one of each part type</td>
</tr>
<tr><td>CONTAINER.ROOTSIGNATUREINCOMPATIBLE</td>
<td>Root Signature in DXIL Container must be compatible with shader</td>
</tr>
<tr><td>DECL.ATTRSTRUCT</td>
<td>Attributes parameter must be struct type</td>
</tr>
<tr><td>DECL.DXILFNEXTERN</td>
<td>External function must be a DXIL function</td>
</tr>
<tr><td>DECL.DXILNSRESERVED</td>
<td>The DXIL reserved prefixes must only be used by built-in functions and types</td>
</tr>
<tr><td>DECL.EXTRAARGS</td>
<td>Extra arguments not allowed for shader functions</td>
</tr>
<tr><td>DECL.FNATTRIBUTE</td>
<td>Functions should only contain known function attributes</td>
</tr>
<tr><td>DECL.FNFLATTENPARAM</td>
<td>Function parameters must not use struct types</td>
</tr>
<tr><td>DECL.FNISCALLED</td>
<td>Functions can only be used by call instructions</td>
</tr>
<tr><td>DECL.MULTIPLENODEINPUTS</td>
<td>A node shader may not have more than one input record</td>
</tr>
<tr><td>DECL.NODELAUNCHINPUTTYPE</td>
<td>Invalid input record type for node launch type</td>
</tr>
<tr><td>DECL.NOTUSEDEXTERNAL</td>
<td>External declaration should not be used</td>
</tr>
<tr><td>DECL.PARAMSTRUCT</td>
<td>Callable function parameter must be struct type</td>
</tr>
<tr><td>DECL.PAYLOADSTRUCT</td>
<td>Payload parameter must be struct type</td>
</tr>
<tr><td>DECL.RAYQUERYINFNSIG</td>
<td>Rayquery objects not allowed in function signatures</td>
</tr>
<tr><td>DECL.RESOURCEINFNSIG</td>
<td>Resources not allowed in function signatures</td>
</tr>
<tr><td>DECL.SHADERMISSINGARG</td>
<td>payload/params/attributes parameter is required for certain shader types</td>
</tr>
<tr><td>DECL.SHADERRETURNVOID</td>
<td>Shader functions must return void</td>
</tr>
<tr><td>DECL.USEDEXTERNALFUNCTION</td>
<td>External function must be used</td>
</tr>
<tr><td>DECL.USEDINTERNAL</td>
<td>Internal declaration must be used</td>
</tr>
<tr><td>FLOW.DEADLOOP</td>
<td>Loop must have break.</td>
</tr>
<tr><td>FLOW.FUNCTIONCALL</td>
<td>Function with parameter is not permitted</td>
</tr>
<tr><td>FLOW.NORECURSION</td>
<td>Recursion is not permitted.</td>
</tr>
<tr><td>FLOW.REDUCIBLE</td>
<td>Execution flow must be reducible.</td>
</tr>
<tr><td>INSTR.ALLOWED</td>
<td>Instructions must be of an allowed type.</td>
</tr>
<tr><td>INSTR.ATOMICCONST</td>
<td>Constant destination to atomic.</td>
</tr>
<tr><td>INSTR.ATOMICINTRINNONUAV</td>
<td>Non-UAV destination to atomic intrinsic.</td>
</tr>
<tr><td>INSTR.ATOMICOPNONGROUPSHAREDORRECORD</td>
<td>Non-groupshared or node record destination to atomic operation.</td>
</tr>
<tr><td>INSTR.ATTRIBUTEATVERTEXNOINTERPOLATION</td>
<td>Attribute %0 must have nointerpolation mode in order to use GetAttributeAtVertex function.</td>
</tr>
<tr><td>INSTR.BARRIERFLAGINVALID</td>
<td>Invalid %0 flags on DXIL operation '%1'</td>
</tr>
<tr><td>INSTR.BARRIERMODEFORNONCS</td>
<td>sync in a non-Compute/Amplification/Mesh/Node Shader must only sync UAV (sync_uglobal).</td>
</tr>
<tr><td>INSTR.BARRIERMODENOMEMORY</td>
<td>sync must include some form of memory barrier - _u (UAV) and/or _g (Thread Group Shared Memory).  Only _t (thread group sync) is optional.</td>
</tr>
<tr><td>INSTR.BARRIERMODEUSELESSUGROUP</td>
<td>sync can't specify both _ugroup and _uglobal. If both are needed, just specify _uglobal.</td>
</tr>
<tr><td>INSTR.BARRIERNONCONSTANTFLAGARGUMENT</td>
<td>Memory type, access, or sync flag is not constant</td>
</tr>
<tr><td>INSTR.BUFFERUPDATECOUNTERONRESHASCOUNTER</td>
<td>BufferUpdateCounter valid only when HasCounter is true.</td>
</tr>
<tr><td>INSTR.BUFFERUPDATECOUNTERONUAV</td>
<td>BufferUpdateCounter valid only on UAV.</td>
</tr>
<tr><td>INSTR.CALLOLOAD</td>
<td>Call to DXIL intrinsic must match overload signature</td>
</tr>
<tr><td>INSTR.CANNOTPULLPOSITION</td>
<td>pull-model evaluation of position disallowed</td>
</tr>
<tr><td>INSTR.CBUFFERCLASSFORCBUFFERHANDLE</td>
<td>Expect Cbuffer for CBufferLoad handle.</td>
</tr>
<tr><td>INSTR.CBUFFEROUTOFBOUND</td>
<td>Cbuffer access out of bound.</td>
</tr>
<tr><td>INSTR.CHECKACCESSFULLYMAPPED</td>
<td>CheckAccessFullyMapped should only be used on resource status.</td>
</tr>
<tr><td>INSTR.COORDINATECOUNTFORRAWTYPEDBUF</td>
<td>raw/typed buffer don't need 2 coordinates.</td>
</tr>
<tr><td>INSTR.COORDINATECOUNTFORSTRUCTBUF</td>
<td>structured buffer require 2 coordinates.</td>
</tr>
<tr><td>INSTR.CREATEHANDLEIMMRANGEID</td>
<td>Local resource must map to global resource.</td>
</tr>
<tr><td>INSTR.DXILSTRUCTUSER</td>
<td>Dxil struct types should only be used by ExtractValue.</td>
</tr>
<tr><td>INSTR.DXILSTRUCTUSEROUTOFBOUND</td>
<td>Index out of bound when extract value from dxil struct types.</td>
</tr>
<tr><td>INSTR.EVALINTERPOLATIONMODE</td>
<td>Interpolation mode on %0 used with eval_* instruction must be linear, linear_centroid, linear_noperspective, linear_noperspective_centroid, linear_sample or linear_noperspective_sample.</td>
</tr>
<tr><td>INSTR.EXTRACTVALUE</td>
<td>ExtractValue should only be used on dxil struct types and cmpxchg.</td>
</tr>
<tr><td>INSTR.FAILTORESLOVETGSMPOINTER</td>
<td>TGSM pointers must originate from an unambiguous TGSM global variable.</td>
</tr>
<tr><td>INSTR.HANDLENOTFROMCREATEHANDLE</td>
<td>Resource handle should returned by createHandle.</td>
</tr>
<tr><td>INSTR.IMMBIASFORSAMPLEB</td>
<td>bias amount for sample_b must be in the range [%0,%1], but %2 was specified as an immediate.</td>
</tr>
<tr><td>INSTR.INBOUNDSACCESS</td>
<td>Access to out-of-bounds memory is disallowed.</td>
</tr>
<tr><td>INSTR.MINPRECISIONNOTPRECISE</td>
<td>Instructions marked precise may not refer to minprecision values.</td>
</tr>
<tr><td>INSTR.MINPRECISONBITCAST</td>
<td>Bitcast on minprecison types is not allowed.</td>
</tr>
<tr><td>INSTR.MIPLEVELFORGETDIMENSION</td>
<td>Use mip level on buffer when GetDimensions.</td>
</tr>
<tr><td>INSTR.MIPONUAVLOAD</td>
<td>uav load don't support mipLevel/sampleIndex.</td>
</tr>
<tr><td>INSTR.MISSINGSETMESHOUTPUTCOUNTS</td>
<td>Missing SetMeshOutputCounts call.</td>
</tr>
<tr><td>INSTR.MULTIPLEGETMESHPAYLOAD</td>
<td>GetMeshPayload cannot be called multiple times.</td>
</tr>
<tr><td>INSTR.MULTIPLESETMESHOUTPUTCOUNTS</td>
<td>SetMeshOUtputCounts cannot be called multiple times.</td>
</tr>
<tr><td>INSTR.NODERECORDHANDLEUSEAFTERCOMPLETE</td>
<td>Invalid use of completed record handle.</td>
</tr>
<tr><td>INSTR.NOGENERICPTRADDRSPACECAST</td>
<td>Address space cast between pointer types must have one part to be generic address space.</td>
</tr>
<tr><td>INSTR.NOIDIVBYZERO</td>
<td>No signed integer division by zero.</td>
</tr>
<tr><td>INSTR.NOINDEFINITEACOS</td>
<td>No indefinite arccosine.</td>
</tr>
<tr><td>INSTR.NOINDEFINITEASIN</td>
<td>No indefinite arcsine.</td>
</tr>
<tr><td>INSTR.NOINDEFINITEDSXY</td>
<td>No indefinite derivative calculation.</td>
</tr>
<tr><td>INSTR.NOINDEFINITELOG</td>
<td>No indefinite logarithm.</td>
</tr>
<tr><td>INSTR.NONDOMINATINGDISPATCHMESH</td>
<td>Non-Dominating DispatchMesh call.</td>
</tr>
<tr><td>INSTR.NONDOMINATINGSETMESHOUTPUTCOUNTS</td>
<td>Non-Dominating SetMeshOutputCounts call.</td>
</tr>
<tr><td>INSTR.NOREADINGUNINITIALIZED</td>
<td>Instructions should not read uninitialized value.</td>
</tr>
<tr><td>INSTR.NOTONCEDISPATCHMESH</td>
<td>DispatchMesh must be called exactly once in an Amplification shader.</td>
</tr>
<tr><td>INSTR.NOUDIVBYZERO</td>
<td>No unsigned integer division by zero.</td>
</tr>
<tr><td>INSTR.OFFSETONUAVLOAD</td>
<td>uav load don't support offset.</td>
</tr>
<tr><td>INSTR.OLOAD</td>
<td>DXIL intrinsic overload must be valid.</td>
</tr>
<tr><td>INSTR.ONLYONEALLOCCONSUME</td>
<td>RWStructuredBuffers may increment or decrement their counters, but not both.</td>
</tr>
<tr><td>INSTR.OPCODERESERVED</td>
<td>Instructions must not reference reserved opcodes.</td>
</tr>
<tr><td>INSTR.OPCONST</td>
<td>DXIL intrinsic requires an immediate constant operand</td>
</tr>
<tr><td>INSTR.OPCONSTRANGE</td>
<td>Constant values must be in-range for operation.</td>
</tr>
<tr><td>INSTR.OPERANDRANGE</td>
<td>DXIL intrinsic operand must be within defined range</td>
</tr>
<tr><td>INSTR.PTRBITCAST</td>
<td>Pointer type bitcast must be have same size.</td>
</tr>
<tr><td>INSTR.RESOURCECLASSFORLOAD</td>
<td>load can only run on UAV/SRV resource.</td>
</tr>
<tr><td>INSTR.RESOURCECLASSFORSAMPLERGATHER</td>
<td>sample, lod and gather should be on srv resource.</td>
</tr>
<tr><td>INSTR.RESOURCECLASSFORUAVSTORE</td>
<td>store should be on uav resource.</td>
</tr>
<tr><td>INSTR.RESOURCECOORDINATEMISS</td>
<td>coord uninitialized.</td>
</tr>
<tr><td>INSTR.RESOURCECOORDINATETOOMANY</td>
<td>out of bound coord must be undef.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORBUFFERLOADSTORE</td>
<td>buffer load/store only works on Raw/Typed/StructuredBuffer.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORCALCLOD</td>
<td>lod requires resource declared as texture1D/2D/3D/Cube/CubeArray/1DArray/2DArray.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORGATHER</td>
<td>gather requires resource declared as texture/2D/Cube/2DArray/CubeArray.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORGETDIM</td>
<td>Invalid resource kind on GetDimensions.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORSAMPLE</td>
<td>sample/_l/_d requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray/CubeArray.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORSAMPLEC</td>
<td>samplec requires resource declared as texture1D/2D/Cube/1DArray/2DArray/CubeArray.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORTEXTURELOAD</td>
<td>texture load only works on Texture1D/1DArray/2D/2DArray/3D/MS2D/MS2DArray.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORTEXTURESTORE</td>
<td>texture store only works on Texture1D/1DArray/2D/2DArray/3D.</td>
</tr>
<tr><td>INSTR.RESOURCEKINDFORTRACERAY</td>
<td>TraceRay should only use RTAccelerationStructure.</td>
</tr>
<tr><td>INSTR.RESOURCEMAPTOSINGLEENTRY</td>
<td>Fail to map resource to resource table.</td>
</tr>
<tr><td>INSTR.RESOURCEOFFSETMISS</td>
<td>offset uninitialized.</td>
</tr>
<tr><td>INSTR.RESOURCEOFFSETTOOMANY</td>
<td>out of bound offset must be undef.</td>
</tr>
<tr><td>INSTR.RESOURCEUSER</td>
<td>Resource should only be used by Load/GEP/Call.</td>
</tr>
<tr><td>INSTR.SAMPLECOMPTYPE</td>
<td>sample_* instructions require resource to be declared to return UNORM, SNORM or FLOAT.</td>
</tr>
<tr><td>INSTR.SAMPLEINDEXFORLOAD2DMS</td>
<td>load on Texture2DMS/2DMSArray require sampleIndex.</td>
</tr>
<tr><td>INSTR.SAMPLERMODEFORLOD</td>
<td>lod instruction requires sampler declared in default mode.</td>
</tr>
<tr><td>INSTR.SAMPLERMODEFORSAMPLE</td>
<td>sample/_l/_d/_cl_s/gather instruction requires sampler declared in default mode.</td>
</tr>
<tr><td>INSTR.SAMPLERMODEFORSAMPLEC</td>
<td>sample_c_*/gather_c instructions require sampler declared in comparison mode.</td>
</tr>
<tr><td>INSTR.SIGNATUREOPERATIONNOTINENTRY</td>
<td>Dxil operation for input output signature must be in entryPoints.</td>
</tr>
<tr><td>INSTR.STATUS</td>
<td>Resource status should only be used by CheckAccessFullyMapped.</td>
</tr>
<tr><td>INSTR.STRUCTBITCAST</td>
<td>Bitcast on struct types is not allowed.</td>
</tr>
<tr><td>INSTR.SVCONFLICTINGLAUNCHMODE</td>
<td>Input system values are compatible with node shader launch mode.</td>
</tr>
<tr><td>INSTR.TEXTUREOFFSET</td>
<td>offset texture instructions must take offset which can resolve to integer literal in the range -8 to 7.</td>
</tr>
<tr><td>INSTR.TGSMRACECOND</td>
<td>Race condition writing to shared memory detected, consider making this write conditional.</td>
</tr>
<tr><td>INSTR.UNDEFINEDVALUEFORUAVSTORE</td>
<td>Assignment of undefined values to UAV.</td>
</tr>
<tr><td>INSTR.UNDEFRESULTFORGETDIMENSION</td>
<td>GetDimensions used undef dimension %0 on %1.</td>
</tr>
<tr><td>INSTR.WRITEMASKFORTYPEDUAVSTORE</td>
<td>store on typed uav must write to all four components of the UAV.</td>
</tr>
<tr><td>INSTR.WRITEMASKGAPFORUAV</td>
<td>UAV write mask must be contiguous, starting at x: .x, .xy, .xyz, or .xyzw.</td>
</tr>
<tr><td>INSTR.WRITEMASKMATCHVALUEFORUAVSTORE</td>
<td>uav store write mask must match store value mask, write mask is %0 and store value mask is %1.</td>
</tr>
<tr><td>META.BARYCENTRICSFLOAT3</td>
<td>only 'float3' type is allowed for SV_Barycentrics.</td>
</tr>
<tr><td>META.BARYCENTRICSINTERPOLATION</td>
<td>SV_Barycentrics cannot be used with 'nointerpolation' type.</td>
</tr>
<tr><td>META.BARYCENTRICSTWOPERSPECTIVES</td>
<td>There can only be up to two input attributes of SV_Barycentrics with different perspective interpolation mode.</td>
</tr>
<tr><td>META.BRANCHFLATTEN</td>
<td>Can't use branch and flatten attributes together.</td>
</tr>
<tr><td>META.CLIPCULLMAXCOMPONENTS</td>
<td>Combined elements of SV_ClipDistance and SV_CullDistance must fit in 8 components</td>
</tr>
<tr><td>META.CLIPCULLMAXROWS</td>
<td>Combined elements of SV_ClipDistance and SV_CullDistance must fit in two rows.</td>
</tr>
<tr><td>META.COMPUTEWITHNODE</td>
<td>Compute entry must not have node metadata</td>
</tr>
<tr><td>META.CONTROLFLOWHINTNOTONCONTROLFLOW</td>
<td>Control flow hint only works on control flow inst.</td>
</tr>
<tr><td>META.DENSERESIDS</td>
<td>Resource identifiers must be zero-based and dense.</td>
</tr>
<tr><td>META.DUPLICATESYSVALUE</td>
<td>System value may only appear once in signature</td>
</tr>
<tr><td>META.ENTRYFUNCTION</td>
<td>entrypoint not found.</td>
</tr>
<tr><td>META.FLAGSUSAGE</td>
<td>Flags must match usage.</td>
</tr>
<tr><td>META.FORCECASEONSWITCH</td>
<td>Attribute forcecase only works for switch.</td>
</tr>
<tr><td>META.GLCNOTONAPPENDCONSUME</td>
<td>globallycoherent cannot be used with append/consume buffers: '%0'.</td>
</tr>
<tr><td>META.INTEGERINTERPMODE</td>
<td>Interpolation mode on integer must be Constant</td>
</tr>
<tr><td>META.INTERPMODEINONEROW</td>
<td>Interpolation mode must be identical for all elements packed into the same row.</td>
</tr>
<tr><td>META.INTERPMODEVALID</td>
<td>Interpolation mode must be valid</td>
</tr>
<tr><td>META.INVALIDCONTROLFLOWHINT</td>
<td>Invalid control flow hint.</td>
</tr>
<tr><td>META.KNOWN</td>
<td>Named metadata should be known</td>
</tr>
<tr><td>META.MAXTESSFACTOR</td>
<td>Hull Shader MaxTessFactor must be [%0..%1].  %2 specified.</td>
</tr>
<tr><td>META.NOENTRYPROPSFORENTRY</td>
<td>Entry point %0 must have entry properties.</td>
</tr>
<tr><td>META.NOSEMANTICOVERLAP</td>
<td>Semantics must not overlap</td>
</tr>
<tr><td>META.REQUIRED</td>
<td>Required metadata missing.</td>
</tr>
<tr><td>META.SEMAKINDMATCHESNAME</td>
<td>Semantic name must match system value, when defined.</td>
</tr>
<tr><td>META.SEMAKINDVALID</td>
<td>Semantic kind must be valid</td>
</tr>
<tr><td>META.SEMANTICCOMPTYPE</td>
<td>%0 must be %1.</td>
</tr>
<tr><td>META.SEMANTICINDEXMAX</td>
<td>System value semantics have a maximum valid semantic index</td>
</tr>
<tr><td>META.SEMANTICLEN</td>
<td>Semantic length must be at least 1 and at most 64.</td>
</tr>
<tr><td>META.SEMANTICSHOULDBEALLOCATED</td>
<td>Semantic should have a valid packing location</td>
</tr>
<tr><td>META.SEMANTICSHOULDNOTBEALLOCATED</td>
<td>Semantic should have a packing location of -1</td>
</tr>
<tr><td>META.SIGNATURECOMPTYPE</td>
<td>signature %0 specifies unrecognized or invalid component type.</td>
</tr>
<tr><td>META.SIGNATUREDATAWIDTH</td>
<td>Data width must be identical for all elements packed into the same row.</td>
</tr>
<tr><td>META.SIGNATUREILLEGALCOMPONENTORDER</td>
<td>Component ordering for packed elements must be: arbitrary &lt; system value &lt; system generated value</td>
</tr>
<tr><td>META.SIGNATUREINDEXCONFLICT</td>
<td>Only elements with compatible indexing rules may be packed together</td>
</tr>
<tr><td>META.SIGNATUREOUTOFRANGE</td>
<td>Signature elements must fit within maximum signature size</td>
</tr>
<tr><td>META.SIGNATUREOVERLAP</td>
<td>Signature elements may not overlap in packing location.</td>
</tr>
<tr><td>META.STRUCTBUFALIGNMENT</td>
<td>StructuredBuffer stride not aligned</td>
</tr>
<tr><td>META.STRUCTBUFALIGNMENTOUTOFBOUND</td>
<td>StructuredBuffer stride out of bounds</td>
</tr>
<tr><td>META.SYSTEMVALUEROWS</td>
<td>System value may only have 1 row</td>
</tr>
<tr><td>META.TARGET</td>
<td>Target triple must be 'dxil-ms-dx'</td>
</tr>
<tr><td>META.TESSELLATOROUTPUTPRIMITIVE</td>
<td>Invalid Tessellator Output Primitive specified. Must be point, line, triangleCW or triangleCCW.</td>
</tr>
<tr><td>META.TESSELLATORPARTITION</td>
<td>Invalid Tessellator Partitioning specified. Must be integer, pow2, fractional_odd or fractional_even.</td>
</tr>
<tr><td>META.TEXTURETYPE</td>
<td>elements of typed buffers and textures must fit in four 32-bit quantities.</td>
</tr>
<tr><td>META.USED</td>
<td>All metadata must be used by dxil.</td>
</tr>
<tr><td>META.VALIDSAMPLERMODE</td>
<td>Invalid sampler mode on sampler .</td>
</tr>
<tr><td>META.VALUERANGE</td>
<td>Metadata value must be within range.</td>
</tr>
<tr><td>META.VERSIONSUPPORTED</td>
<td>Version in metadata must be supported.</td>
</tr>
<tr><td>META.WELLFORMED</td>
<td>Metadata must be well-formed in operand count and types.</td>
</tr>
<tr><td>SM.64BITRAWBUFFERLOADSTORE</td>
<td>i64/f64 rawBufferLoad/Store overloads are allowed after SM 6.3.</td>
</tr>
<tr><td>SM.AMPLIFICATIONSHADERPAYLOADSIZE</td>
<td>For amplification shader with entry '%0', payload size %1 is greater than maximum size of %2 bytes.</td>
</tr>
<tr><td>SM.AMPLIFICATIONSHADERPAYLOADSIZEDECLARED</td>
<td>For amplification shader with entry '%0', payload size %1 is greater than declared size of %2 bytes.</td>
</tr>
<tr><td>SM.APPENDANDCONSUMEONSAMEUAV</td>
<td>BufferUpdateCounter inc and dec on a given UAV (%d) cannot both be in the same shader for shader model less than 5.1.</td>
</tr>
<tr><td>SM.CBUFFERARRAYOFFSETALIGNMENT</td>
<td>CBuffer array offset must be aligned to 16-bytes</td>
</tr>
<tr><td>SM.CBUFFERELEMENTOVERFLOW</td>
<td>CBuffer elements must not overflow</td>
</tr>
<tr><td>SM.CBUFFEROFFSETOVERLAP</td>
<td>CBuffer offsets must not overlap</td>
</tr>
<tr><td>SM.CBUFFERSIZE</td>
<td>CBuffer size must not exceed 65536 bytes</td>
</tr>
<tr><td>SM.CBUFFERTEMPLATETYPEMUSTBESTRUCT</td>
<td>D3D12 constant/texture buffer template element can only be a struct.</td>
</tr>
<tr><td>SM.COMPLETEPOSITION</td>
<td>Not all elements of SV_Position were written.</td>
</tr>
<tr><td>SM.CONSTANTINTERPMODE</td>
<td>Interpolation mode must be constant for MS primitive output.</td>
</tr>
<tr><td>SM.COUNTERONLYONSTRUCTBUF</td>
<td>BufferUpdateCounter valid only on structured buffers.</td>
</tr>
<tr><td>SM.CSNOSIGNATURES</td>
<td>Compute shaders must not have shader signatures.</td>
</tr>
<tr><td>SM.DOMAINLOCATIONIDXOOB</td>
<td>DomainLocation component index out of bounds for the domain.</td>
</tr>
<tr><td>SM.DSINPUTCONTROLPOINTCOUNTRANGE</td>
<td>DS input control point count must be [0..%0].  %1 specified.</td>
</tr>
<tr><td>SM.DXILVERSION</td>
<td>Target shader model requires specific Dxil Version</td>
</tr>
<tr><td>SM.GSINSTANCECOUNTRANGE</td>
<td>GS instance count must be [1..%0].  %1 specified.</td>
</tr>
<tr><td>SM.GSOUTPUTVERTEXCOUNTRANGE</td>
<td>GS output vertex count must be [0..%0].  %1 specified.</td>
</tr>
<tr><td>SM.GSTOTALOUTPUTVERTEXDATARANGE</td>
<td>Declared output vertex count (%0) multiplied by the total number of declared scalar components of output data (%1) equals %2.  This value cannot be greater than %3.</td>
</tr>
<tr><td>SM.GSVALIDINPUTPRIMITIVE</td>
<td>GS input primitive unrecognized.</td>
</tr>
<tr><td>SM.GSVALIDOUTPUTPRIMITIVETOPOLOGY</td>
<td>GS output primitive topology unrecognized.</td>
</tr>
<tr><td>SM.HSINPUTCONTROLPOINTCOUNTRANGE</td>
<td>HS input control point count must be [0..%0].  %1 specified.</td>
</tr>
<tr><td>SM.HULLPASSTHRUCONTROLPOINTCOUNTMATCH</td>
<td>For pass thru hull shader, input control point count must match output control point count</td>
</tr>
<tr><td>SM.INSIDETESSFACTORSIZEMATCHDOMAIN</td>
<td>InsideTessFactor rows, columns (%0, %1) invalid for domain %2.  Expected %3 rows and 1 column.</td>
</tr>
<tr><td>SM.INVALIDRESOURCECOMPTYPE</td>
<td>Invalid resource return type.</td>
</tr>
<tr><td>SM.INVALIDRESOURCEKIND</td>
<td>Invalid resources kind.</td>
</tr>
<tr><td>SM.INVALIDSAMPLERFEEDBACKTYPE</td>
<td>Invalid sampler feedback type.</td>
</tr>
<tr><td>SM.INVALIDTEXTUREKINDONUAV</td>
<td>TextureCube[Array] resources are not supported with UAVs.</td>
</tr>
<tr><td>SM.ISOLINEOUTPUTPRIMITIVEMISMATCH</td>
<td>Hull Shader declared with IsoLine Domain must specify output primitive point or line. Triangle_cw or triangle_ccw output are not compatible with the IsoLine Domain.</td>
</tr>
<tr><td>SM.MAXMSSMSIZE</td>
<td>Total Thread Group Shared Memory storage is %0, exceeded %1.</td>
</tr>
<tr><td>SM.MAXTGSMSIZE</td>
<td>Total Thread Group Shared Memory storage is %0, exceeded %1.</td>
</tr>
<tr><td>SM.MAXTHEADGROUP</td>
<td>Declared Thread Group Count %0 (X*Y*Z) is beyond the valid maximum of %1.</td>
</tr>
<tr><td>SM.MESHPSIGROWCOUNT</td>
<td>For shader '%0', primitive output signatures are taking up more than %1 rows.</td>
</tr>
<tr><td>SM.MESHSHADERINOUTSIZE</td>
<td>For shader '%0', payload plus output size is greater than %1.</td>
</tr>
<tr><td>SM.MESHSHADERMAXPRIMITIVECOUNT</td>
<td>MS max primitive output count must be [0..%0].  %1 specified.</td>
</tr>
<tr><td>SM.MESHSHADERMAXVERTEXCOUNT</td>
<td>MS max vertex output count must be [0..%0].  %1 specified.</td>
</tr>
<tr><td>SM.MESHSHADEROUTPUTSIZE</td>
<td>For shader '%0', vertex plus primitive output size is greater than %1.</td>
</tr>
<tr><td>SM.MESHSHADERPAYLOADSIZE</td>
<td>For mesh shader with entry '%0', payload size %1 is greater than maximum size of %2 bytes.</td>
</tr>
<tr><td>SM.MESHSHADERPAYLOADSIZEDECLARED</td>
<td>For mesh shader with entry '%0', payload size %1 is greater than declared size of %2 bytes.</td>
</tr>
<tr><td>SM.MESHTOTALSIGROWCOUNT</td>
<td>For shader '%0', vertex and primitive output signatures are taking up more than %1 rows.</td>
</tr>
<tr><td>SM.MESHVSIGROWCOUNT</td>
<td>For shader '%0', vertex output signatures are taking up more than %1 rows.</td>
</tr>
<tr><td>SM.MULTISTREAMMUSTBEPOINT</td>
<td>When multiple GS output streams are used they must be pointlists</td>
</tr>
<tr><td>SM.NAME</td>
<td>Target shader model name must be known</td>
</tr>
<tr><td>SM.NOINTERPMODE</td>
<td>Interpolation mode must be undefined for VS input/PS output/patch constant.</td>
</tr>
<tr><td>SM.NOPSOUTPUTIDX</td>
<td>Pixel shader output registers are not indexable.</td>
</tr>
<tr><td>SM.OPCODE</td>
<td>Opcode must be defined in target shader model</td>
</tr>
<tr><td>SM.OPCODEININVALIDFUNCTION</td>
<td>Invalid DXIL opcode usage like StorePatchConstant in patch constant function</td>
</tr>
<tr><td>SM.OPERAND</td>
<td>Operand must be defined in target shader model.</td>
</tr>
<tr><td>SM.OUTPUTCONTROLPOINTCOUNTRANGE</td>
<td>output control point count must be [0..%0].  %1 specified.</td>
</tr>
<tr><td>SM.OUTPUTCONTROLPOINTSTOTALSCALARS</td>
<td>Total number of scalars across all HS output control points must not exceed .</td>
</tr>
<tr><td>SM.PATCHCONSTANTONLYFORHSDS</td>
<td>patch constant signature only valid in HS and DS.</td>
</tr>
<tr><td>SM.PSCONSISTENTINTERP</td>
<td>Interpolation mode for PS input position must be linear_noperspective_centroid or linear_noperspective_sample when outputting oDepthGE or oDepthLE and not running at sample frequency (which is forced by inputting SV_SampleIndex or declaring an input linear_sample or linear_noperspective_sample).</td>
</tr>
<tr><td>SM.PSCOVERAGEANDINNERCOVERAGE</td>
<td>InnerCoverage and Coverage are mutually exclusive.</td>
</tr>
<tr><td>SM.PSMULTIPLEDEPTHSEMANTIC</td>
<td>Pixel Shader only allows one type of depth semantic to be declared.</td>
</tr>
<tr><td>SM.PSOUTPUTSEMANTIC</td>
<td>Pixel Shader allows output semantics to be SV_Target, SV_Depth, SV_DepthGreaterEqual, SV_DepthLessEqual, SV_Coverage or SV_StencilRef, %0 found.</td>
</tr>
<tr><td>SM.PSTARGETCOL0</td>
<td>SV_Target packed location must start at column 0.</td>
</tr>
<tr><td>SM.PSTARGETINDEXMATCHESROW</td>
<td>SV_Target semantic index must match packed row location.</td>
</tr>
<tr><td>SM.RAYSHADERPAYLOADSIZE</td>
<td>For shader '%0', %1 size is smaller than argument's allocation size.</td>
</tr>
<tr><td>SM.RAYSHADERSIGNATURES</td>
<td>Ray tracing shader '%0' should not have any shader signatures.</td>
</tr>
<tr><td>SM.RESOURCERANGEOVERLAP</td>
<td>Resource ranges must not overlap</td>
</tr>
<tr><td>SM.ROVONLYINPS</td>
<td>RasterizerOrdered objects are only allowed in 5.0+ pixel shaders.</td>
</tr>
<tr><td>SM.SAMPLECOUNTONLYON2DMS</td>
<td>Only Texture2DMS/2DMSArray could has sample count.</td>
</tr>
<tr><td>SM.SEMANTIC</td>
<td>Semantic must be defined in target shader model</td>
</tr>
<tr><td>SM.STREAMINDEXRANGE</td>
<td>Stream index (%0) must between 0 and %1.</td>
</tr>
<tr><td>SM.TESSFACTORFORDOMAIN</td>
<td>Required TessFactor for domain not found declared anywhere in Patch Constant data.</td>
</tr>
<tr><td>SM.TESSFACTORSIZEMATCHDOMAIN</td>
<td>TessFactor rows, columns (%0, %1) invalid for domain %2.  Expected %3 rows and 1 column.</td>
</tr>
<tr><td>SM.TGSMUNSUPPORTED</td>
<td>Thread Group Shared Memory not supported %0.</td>
</tr>
<tr><td>SM.THREADGROUPCHANNELRANGE</td>
<td>Declared Thread Group %0 size %1 outside valid range [%2..%3].</td>
</tr>
<tr><td>SM.TRIOUTPUTPRIMITIVEMISMATCH</td>
<td>Hull Shader declared with Tri Domain must specify output primitive point, triangle_cw or triangle_ccw. Line output is not compatible with the Tri domain.</td>
</tr>
<tr><td>SM.UNDEFINEDOUTPUT</td>
<td>Not all elements of output %0 were written.</td>
</tr>
<tr><td>SM.VALIDDOMAIN</td>
<td>Invalid Tessellator Domain specified. Must be isoline, tri or quad.</td>
</tr>
<tr><td>SM.VIEWIDNEEDSSLOT</td>
<td>ViewID requires compatible space in pixel shader input signature</td>
</tr>
<tr><td>SM.WAVESIZEALLZEROWHENUNDEFINED</td>
<td>WaveSize Max and Preferred must be 0 when Min is 0</td>
</tr>
<tr><td>SM.WAVESIZEMAXANDPREFERREDZEROWHENNORANGE</td>
<td>WaveSize Max and Preferred must be 0 to encode min==max</td>
</tr>
<tr><td>SM.WAVESIZEMAXGREATERTHANMIN</td>
<td>WaveSize Max must greater than Min</td>
</tr>
<tr><td>SM.WAVESIZENEEDSDXIL16PLUS</td>
<td>WaveSize is valid only for DXIL version 1.6 and higher.</td>
</tr>
<tr><td>SM.WAVESIZEONCOMPUTEORNODE</td>
<td>WaveSize only allowed on compute or node shaders</td>
</tr>
<tr><td>SM.WAVESIZEPREFERREDINRANGE</td>
<td>WaveSize Preferred must be within Min..Max range</td>
</tr>
<tr><td>SM.WAVESIZERANGENEEDSDXIL18PLUS</td>
<td>WaveSize Range is valid only for DXIL version 1.8 and higher.</td>
</tr>
<tr><td>SM.WAVESIZEVALUE</td>
<td>WaveSize value must be a power of 2 in range [4..128]</td>
</tr>
<tr><td>SM.ZEROHSINPUTCONTROLPOINTWITHINPUT</td>
<td>When HS input control point count is 0, no input signature should exist.</td>
</tr>
<tr><td>TYPES.DEFINED</td>
<td>Type must be defined based on DXIL primitives</td>
</tr>
<tr><td>TYPES.I8</td>
<td>I8 can only be used as immediate value for intrinsic or as i8* via bitcast by lifetime intrinsics.</td>
</tr>
<tr><td>TYPES.INTWIDTH</td>
<td>Int type must be of valid width</td>
</tr>
<tr><td>TYPES.NOMULTIDIM</td>
<td>Only one dimension allowed for array type.</td>
</tr>
<tr><td>TYPES.NOPTRTOPTR</td>
<td>Pointers to pointers, or pointers in structures are not allowed.</td>
</tr>
<tr><td>TYPES.NOVECTOR</td>
<td>Vector types must not be present</td>
</tr>
</tbody>
</table>
<a name="modules-and-linking"></a>
<h2><a class="toc-backref" href="#toc-entry-61">Modules and Linking</a></h2>
<p>HLSL has linking capabilities to enable third-party libraries. The linking step happens before shader DXIL is given to the driver compilers.
Experimental library generation is added in DXIL1.1. A library could be created by compile with lib_6_1 profile.
A library is a dxil container like the compile result of other shader profiles. The difference is library will keep information for linking like resource link info and entry function signatures.
Library support is not part of DXIL spec. Only requirement is linked shader must be valid DXIL.</p>
<a name="additional-notes"></a>
<h2><a class="toc-backref" href="#toc-entry-62">Additional Notes</a></h2>
<p>These additional notes are not normative for DXIL, and are included for the convenience of implementers.</p>
<a name="other-versioned-components"></a>
<h3><a class="toc-backref" href="#toc-entry-63">Other Versioned Components</a></h3>
<p>In addition to shader model, DXIL and bitcode representation versions, two other interesting versioned components are discussed: the supporting operating system and runtime, and the HLSL language.</p>
<p>Support is provided in the Microsoft Windows family of operating systems, when running on the D3D12 runtime.</p>
<p>The HLSL language is versioned independently of DXIL, and currently follows an 'HLSL &lt;year&gt;' naming scheme. HLSL 2015 is the dialect supported by the d3dcompiler_47 library; a limited form of support is provided in the open source HLSL on LLVM project. HLSL 2016 is the version supported by the current HLSL on LLVM project, which removes some features (primarily effect framework syntax, backquote operator) and adds new ones (wave intrinsics and basic i64 support).</p>
<a name="dxil-container-format"></a>
<h3><a class="toc-backref" href="#toc-entry-64">DXIL Container Format</a></h3>
<p>DXIL is typically encapsulated in a DXIL container. A DXIL container is composed of a header, a sequence of part lengths, and a sequence of parts.</p>
<p>The following C declaration describes this structure:</p>
<pre>
struct DxilContainerHeader {
  uint32_t  HeaderFourCC;
  uint8_t   Digest[DxilContainerHashSize];
  uint16_t  MajorVersion;
  uint16_t  MinorVersion;
  uint32_t  ContainerSizeInBytes; // From start of this header
  uint32_t  PartCount;
  // Structure is followed by uint32_t PartOffset[PartCount];
  // The offset is to a DxilPartHeader.
};
</pre>
<p>Each part has a standard header, followed by a part-specify body:</p>
<pre>
struct DxilPartHeader {
  uint32_t  PartFourCC; // Four char code for part type.
  uint32_t  PartSize;   // Byte count for PartData.
  // Structure is followed by uint8_t PartData[PartSize].
};
</pre>
<p>The DXIL program is found in a part with the following body:</p>
<pre>
struct DxilProgramHeader {
  uint32_t          ProgramVersion;   /// Major and minor version of shader, including type.
  uint32_t          SizeInUint32;     /// Size in uint32_t units including this header.
  uint32_t DxilMagic;       // 0x4C495844, ASCII &quot;DXIL&quot;.
  uint32_t DxilVersion;     // DXIL version.
  uint32_t BitcodeOffset;   // Offset to LLVM bitcode (from DxilMagic).
  uint32_t BitcodeSize;     // Size of LLVM bitcode.
  // Followed by uint8_t[BitcodeHeader.BitcodeSize] after possible gap from BitcodeOffset
};
</pre>
<p>The bitcode payload is defined as per bitcode encoding.</p>
<a name="future-directions"></a>
<h3><a class="toc-backref" href="#toc-entry-65">Future Directions</a></h3>
<p>This section provides background on future directions for DXIL that may or may not materialize. They imply a new version of DXIL.</p>
<p>It's desirable to support generic pointers, pointing to one of other kinds of pointers. If the compiler fails to disambiguate, memory access is done via a generic pointer; the HLSL compiler will warn the user about each access that it cannot disambiguate. Not supported for SM6.</p>
<p>HLSL will eventually support more primitive types such as i8, i16, i32, i64, half, float, double, as well as declspec(align(n)) and #pragma pack(n) directives. SM6.0 will eventually require byte-granularity access support in hardware, especially writes. Not supported for SM6.</p>
<p>There will be a Requires32BitAlignedAccesses CAP flag. If absent, this would indicate that the shader requires writes that (1) do not write full four bytes, or (2) are not aligned on four-byte boundary. If hardware does not natively support these, the shader is rejected. Programmers can work around this hardware limitation by manually aligning smaller data on four-byte boundary in HLSL.</p>
<p>When libraries are supported as first-class DXIL constructs, &quot;lib_*&quot; shader models can specify more than one entry point per module; the other shader models must specify exactly one entry point.</p>
<p>The target machine specification for HLSL might specify a 64-bit pointer side with 64-bit offsets.</p>
<p>Hardware support for generic pointer is essential for HLSL next as a fallback mechanism for cases when compiler cannot disambiguate pointer's address space.</p>
<p>Future DXIL will change how half and i16 are treated:
* i16 will have to be supported natively either in hardware or via emulation,
* half's behavior will depend on the value of RequiresHardwareHalf CAP; if it's not set, half can be treated as min-precision type (min16float); i.e., computation may be done with values implicitly promoted to floats; if it's set and hardware does not support half type natively, the driver compiler can either emulate exact IEEE half behavior or fail shader creation.</p>
<a name="pending-specification-work"></a>
<h2><a class="toc-backref" href="#toc-entry-66">Pending Specification Work</a></h2>
<p>The following work on this specification is still pending:</p>
<ul class="simple">
<li>Consider moving some additional tables and lists into hctdb and cross-reference.</li>
<li>Complete the extended documentation for instructions.</li>
</ul>
